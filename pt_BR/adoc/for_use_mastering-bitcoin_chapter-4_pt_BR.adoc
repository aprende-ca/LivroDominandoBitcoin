[[ch04_keys_addresses]]
== Chaves, Endereços

((("criptografia", "definição")))((("criptografia", see="também chaves e endereços")))Você já deve ter ouvido falar que o bitcoin é baseado em _criptografia_, um ramo da matemática usado extensivamente na segurança de computadores. A palavra criptografia significa "escrita secreta" em grego, mas a ciência da criptografia abrange mais do que apenas a escrita secreta, conhecida como encriptação. A criptografia também pode ser usada para provar o conhecimento de um segredo sem revelar esse segredo (assinatura digital) ou para provar a autenticidade de dados (impressão digital eletrônica). Esses tipos de provas criptográficas são ferramentas matemáticas essenciais para o bitcoin, sendo amplamente utilizadas em aplicações de bitcoin. ((("encriptação")))((("encriptação", see="também chaves e endereços")))Ironicamente, a encriptação não é uma parte importante do bitcoin, pois suas comunicações e dados de transação não são encriptados e não precisam ser encriptados para proteger os fundos. Neste capítulo, apresentaremos algumas das criptografias usadas no bitcoin para controlar a propriedade de fundos, na forma de chaves, endereços e carteiras.

=== Introdução

((("digital keys", see="keys and addresses")))((("keys and addresses", "overview of", id="KAover04")))((("digital signatures", "purpose of")))Ownership of bitcoin is established through _digital keys_, _Bitcoin addresses_, and _digital signatures_. The digital keys are not actually stored in the network, but are instead created and stored by users in a file, or simple database, called a _wallet_. The digital keys in a user's wallet are completely independent of the Bitcoin protocol and can be generated and managed by the user's wallet software without reference to the blockchain or access to the internet. Keys enable many of the interesting properties of bitcoin, including decentralized trust and control, ownership attestation, and the cryptographic-proof security model.

A maioria das transações de bitcoin necessita de uma assinatura digital válida para ser incluída na _blockchain_ (na cadeia de blocos), que só pode ser gerada com uma chave secreta; portanto, qualquer um com um cópia dessa chave tem o controle dos bitcoins. ((("testemunhas")))A assinatura digital usada para gastar os fundos também é chamada de _testemunha_, um termo utilizado na criptografia. Os dados de testemunha em uma transação de bitcoin atestam a verdadeira posse dos fundos que estão sendo gastos.

((("chaves públicas e privadas", "pares de chaves")))((("chaves públicas e privadas", see="também chaves e endereços"))) As chaves vêm em pares que consistem em uma chave privada (secreta) e uma chave pública. Imagine que a chave pública é similar ao número de uma conta bancária e que a chave privada é similar a um PIN secreto ou uma assinatura em um cheque, que fornece controle sobre a conta. Estas chaves digitais são raramente vistas pelos usuários do bitcoin. Para a maioria dos usuários, elas ficam armazenadas dentro do arquivo de carteira e são gerenciadas por um software de carteira de bitcoin.

In the payment portion of a bitcoin transaction, the recipient's public key is represented by its digital fingerprint, called a _Bitcoin address_, which is used in the same way as the beneficiary name on a check (i.e., "Pay to the order of"). In most cases, a Bitcoin address is generated from and corresponds to a public key. However, not all Bitcoin addresses represent public keys; they can also represent other beneficiaries such as scripts, as we will see later in this chapter. This way, Bitcoin addresses abstract the recipient of funds, making transaction destinations flexible, similar to paper checks: a single payment instrument that can be used to pay into people's accounts, pay into company accounts, pay for bills, or pay to cash. The Bitcoin address is the only representation of the keys that users will routinely see, because this is the part they need to share with the world.

Primeiro, apresentaremos a criptografia e explicaremos a matemática usada no bitcoin. A seguir, veremos como as chaves são geradas, armazenadas e gerenciadas. Analisaremos os vários formatos de codificação usados para representar chaves privadas e públicas, endereços e endereços de script. Por fim, veremos o uso avançado de chaves e endereços: endereços personalizados, endereços multiassinatura, endereços de script e carteiras de papel.

==== Criptografia de Chave Pública e Criptomoeda

((("chaves e endereços", "visão geral das", "criptografia de chave pública")))((("moedas digitais", "criptomoeda")))A criptografia de chave pública foi inventada nos anos 1970s e é uma base matemática fundamental para a segurança da computação e para a segurança da informação.

Desde a invenção da criptografia de chave pública, muitas funções matemáticas úteis foram descobertas, como a exponenciação de números primos e a multiplicação de curva elíptica. Essas funções matemáticas são praticamente irreversíveis, o que significa que elas são fáceis de serem calculadas em uma direção e inviáveis de serem calculadas na direção oposta. Baseando-se nessas funções matemáticas, a criptografia permite a criação de segredos digitais e assinaturas digitais que não podem ser falsificadas. O bitcoin usa a multiplicação de curva elíptica como a base para sua criptografia.

No bitcoin, usamos a criptografia de chave pública para criar um par de chaves que controla o acesso aos bitcoins. O par de chaves consiste em uma chave privada e uma chave pública única, que é derivada da chave privada. A chave pública é usada para receber os fundos, e a chave privada é usada para assinar transações que gastam os fundos.

Existe uma relação matemática entre as chaves pública e privada que permite que a chave privada seja usada para gerar assinaturas em mensagens. Essas assinaturas podem ser validadas em relação à chave pública, sem a necessidade de se revelar a chave privada.

When spending bitcoin, the current bitcoin owner presents her public key and a signature (different each time, but created from the same private key) in a transaction to spend those bitcoin. Through the presentation of the public key and signature, everyone in the Bitcoin network can verify and accept the transaction as valid, confirming that the person transferring the bitcoin owned them at the time of the transfer.

[TIP]
====
((("chaves e endereços", "visão geral das", "pares de chaves")))Na maioria das implementações de carteira, as chaves privada e pública são armazenadas juntas, por conveniência, como um _par de chaves_. No entanto, a chave pública pode ser calculada a partir da chave privada, então também é possível se armazenar apenas a chave privada.
====

[[private_public_keys]]
==== Chaves Privada e Pública

((("keys and addresses", "overview of", "private and public key pairs")))((("elliptic curve cryptography")))((("cryptography", "elliptic curve cryptography")))A bitcoin wallet contains a collection of key pairs, each consisting of a private key and a public key. The private key (k) is a number, usually picked at random. From the private key, we use elliptic curve multiplication, a one-way cryptographic function, to generate a public key (K). From the public key (K), we use a one-way cryptographic hash function to generate a Bitcoin address (A). In this section, we will start with generating the private key, look at the elliptic curve math that is used to turn that into a public key, and finally, generate a Bitcoin address from the public key. The relationship between private key, public key, and Bitcoin address is shown in <<k_to_K_to_A>>.

[[k_to_K_to_A]]
.Private key, public key, and Bitcoin address
image::images/mbc2_0401.png["privk_to_pubK_to_addressA"]

.Por que usar Criptografia Assimétrica (Chaves Públicas/Privadas)?
****
((("criptografia", "assimétrica")))((("assinaturas digitais", "criptografia assimétrica e")))((("criptografia assimétrica")))Por que a criptografia assimétrica é usada no bitcoin? Ela não é usada para "encriptar" (tornar secretas) as transações. Em vez disso, a utilidade da criptografia assimétrica é a capacidade de gerar _assinaturas digitais_. Uma chave privada pode ser aplicada à impressão digital de uma transação para produzir uma assinatura numérica. Essa assinatura só pode ser produzida por alguém que saiba a chave privada. No entanto, qualquer pessoa com acesso à chave pública e à impressão digital da transação pode usá-las para _verificar_ a assinatura. Esta propriedade útil da criptografia assimétrica permite que qualquer pessoa possa verificar a assinatura de qualquer transação, enquanto garante que apenas os donos das chaves privadas possam produzir assinaturas válidas.
****

[[private_keys]]
==== Chaves Privadas

((("keys and addresses", "overview of", "private key generation")))((("warnings and cautions", "private key protection")))A private key is simply a number, picked at random. Ownership and control over the private key is the root of user control over all funds associated with the corresponding Bitcoin address. The private key is used to create signatures that are required to spend bitcoin by proving ownership of funds used in a transaction. The private key must remain secret at all times, because revealing it to third parties is equivalent to giving them control over the bitcoin secured by that key. The private key must also be backed up and protected from accidental loss, because if it's lost it cannot be recovered and the funds secured by it are forever lost, too.

[TIP]
====
A chave privada do bitcoin é apenas um número. Você pode escolher suas chaves privadas aleatoriamente usando apenas uma moeda, um lápis e um papel: jogue a moeda 256 vezes e você terá os dígitos binários de uma chave privada aleatória que você pode usar em uma carteira de bitcoin. Em seguida, a chave pública pode ser gerada a partir dessa chave privada.
====

===== Gerando uma chave privada a partir de um número aleatório

O primeiro e mais importante passo na geração de chaves é encontrar uma fonte segura de entropia, ou aleatoriedade. Criar uma chave de bitcoin é essencialmente a mesma coisa que pedir para que alguém "Escolha um número entre 1 e 2^256^". O método exato que você usa para escolher esse número não importa, contanto que não seja previsível ou repetível. O software do bitcoin baseia-se em geradores de número aleatório do sistema operacional para produzir 256 bits de entropia (aleatoriedade). Normalmente, o gerador de número aleatório do sistema operacional é inicializado por uma fonte humana de aleatoriedade, razão pela qual você pode ser solicitado a mexer o ponteiro do mouse aleatoriamente por alguns segundos.

Mais precisamente, a chave privada pode ser qualquer número entre +0+ e +n - 1+, onde n é uma constante (n = 1,158 * 10^77^, ligeiramente menor do que 2^256^) definida como a ordem da curva elíptica usada no bitcoin (ver <<elliptic_curve>>). Para criar tal chave, escolhemos aleatoriamente um número de 256 bits e verificamos se ele é menor do que +n+. Em termos de programação, isto é geralmente obtido fornecendo-se uma _string_ maior de bits aleatórios, coletados a partir de uma fonte de aleatoriedade criptograficamente segura, ao algoritmo de hash SHA256, o qual produzirá convenientemente um número de 256 bits. Se o resultado for menor do que +n+, temos uma chave privada satisfatória. Caso contrário, simplesmente tentamos novamente com outro número aleatório.

[WARNING]
====
((("números aleatórios", "geração de número aleatório")))((("entropia", "geração de número aleatório")))Não escreva o seu próprio código para criar um número aleatório, nem utilize um gerador de número aleatório "simples" oferecido pela sua linguagem de programação. Use um gerador de número pseudo-aleatório criptograficamente seguro (CSPRNG, na sigla em inglês) com uma semente derivada de uma fonte com entropia suficiente. Estude a documentação da biblioteca geradora de número aleatório que você escolher para se certificar de que ela é criptograficamente segura. A correta implementação do CSPRNG é crucial para a segurança das chaves.
====

Abaixo vemos uma chave privada (k) gerada aleatoriamente, exibida em formato hexadecimal (256 bits exibidos como 64 dígitos hexadecimais, cada um com 4 bits):

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----


[TIP]
====
O tamanho do número de chaves privadas que podem existir no bitcoin é tão grande (2^256), que chega a ser incompreensível. Isso é aproximadamente 10^77 na escala decimal. Para fins comparativos, estima-se que o universo visível contenha 10^80 átomos.
====

((("comando dumpprivkey"))) Para gerar uma nova chave com o cliente Bitcoin Core (veja <<ch03_bitcoin_client>>), use o comando +getnewaddress+. Por motivos de segurança, ele exibe apenas o endereço, e não a chave privada. Para pedir ao +bitcoind+ para expor a chave privada, use o comando +dumpprivkey+. O comando +dumpprivkey+ mostra a chave privada em um formato codificado por checksum Base58 chamado _Wallet Import Format_ (WIF), que examinaremos com mais detalhes em <<priv_formats>>. Aqui está um exemplo de geração e exibição de uma chave privada usando estes dois comandos:

----
$ bitcoin-cli getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

O comando +dumpprivkey+ abre a carteira e extrai a chave privada que foi gerada pelo comando +getnewaddress+. Não é possível para o +bitcoind+ saber a chave privada a partir do endereço, a menos que ambos estejam armazenados na carteira.

[TIP]
=====================================================================
O comando +dumpprivkey+ não gera uma chave privada a partir de um endereço, pois isso é impossível. O comando simplesmente revela a chave privada que já é conhecida pela carteira e que foi gerada pelo comando +getnewaddress+.
=====================================================================

[role="pagebreak-before"]
Você também pode usar a ferramenta de linha de comando Bitcoin Explorer (ver o <<appdx_bx>>) para gerar e exibir chaves privadas com os comandos +seed+, +ec-new+ e +ec-to-wif+:

----
$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

[[pubkey]]
==== Chaves Públicas

((("chaves e endereços", "visão geral das", "cálculo da chave pública")))((("ponto gerador")))A chave pública é calculada a partir da chave privada usando multiplicação de curva elíptica, que é irreversível: _K_ = _k_ * _G_, onde _k_ é a chave privada, _G_ é um ponto constante chamado de _ponto gerador_ e _K_ é a chave pública resultante. A operação inversa, também conhecida como "encontrar o logaritmo discreto"—calcular a chave privada _k_, se você conhece a chave pública __K__—é tão difícil quanto tentar todos os possíveis valores de _k_, ou seja, é uma busca de força bruta. Antes de demonstrarmos como gerar uma chave pública a partir de uma chave privada, vamos analisar a criptografia de curva elíptica em um pouco mais de detalhes.

[TIP]
====
A multiplicação de curva elíptica é um tipo de função que os profissionais de criptografia chamam de função de "sentido único": ela é fácil de ser feita em uma direção (multiplicação) e impossível de ser feita na direção inversa ("divisão" ou encontrar o logaritmo discreto). O proprietário da chave privada pode facilmente criar a chave pública e depois compartilhá-la com outras pessoas, sabendo que ninguém conseguirá inverter a função e calcular a chave privada a partir da chave pública. Esse truque matemático é a base para as assinaturas digitais infalsificáveis e seguras que comprovam a posse de fundos no bitcoin.
====

[[elliptic_curve]]
==== Explicando a Criptografia de Curva Elíptica

((("chaves e endereços", "visão geral das", "criptografia de curva elíptica")))((("criptografia de curva elíptica", id="eliptic04")))((("criptografia", "criptografia de curva elíptica", id="Celliptic04")))A criptografia de curva elíptica é um tipo de criptografia assimétrica ou criptografia de chave pública baseada em um problema logarítmico discreto que é expressado por adição e multiplicação nos pontos de uma curva elíptica.

A <<ecc-curve>> é um exemplo de uma curva elíptica, similar à utilizada pelo bitcoin.

[[ecc-curve]]
[role="smallerthirty"]
.Uma curva elíptica
image::images/mbc2_0402.png["ecc-curve"]

O bitcoin usa uma curva elíptica específica e um conjunto específico de constantes matemáticas, conforme definidos em um padrão chamado +secp256k1+, estabelecido pelo Instituto Nacional de Padronização e Tecnologia (_Institute of Standards and Technology_ ou NIST). A curva +secp256k1+ é definida pela seguinte função, que produz uma curva elíptica:

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

ou

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

O _mod p_ (módulo de número primo p) indica que essa curva está sobre um corpo finito de ordem prima _p_, também escrito como latexmath:[\( \mathbb{F}_p \)], onde p = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1, um número primo muito grande.

Como a curva é definida sobre um corpo finito de ordem prima ao invés de números reais, ela parece um padrão de pontos espalhados em duas dimensões, o que a torna difícil de ser visualizada. Contudo, a matemática é idêntica à matemática de uma curva elíptica sobre números reais. Como um exemplo, a <<ecc-over-F17-math>> mostra a mesma curva elíptica sobre um corpo finito muito menor, de ordem prima 17, mostrando um padrão de pontos em uma grade. A curva elíptica +secp256k1+ do bitcoin pode ser imaginada como um padrão muito mais complexo de pontos em uma grade absurdamente grande.

[[ecc-over-F17-math]]
[role="smallersixty"]
.Criptografia de curva elíptica: visualizando uma curva elíptica sobre F(p), com p=17
image::images/mbc2_0403.png["ecc-over-F17-math"]

Então, por exemplo, a seguir está um ponto P com coordenadas (x,y) que é um ponto na curva +secp256k1+:

----
P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)
----

O <<example_4_1>> mostra como você pode verificar isso por conta própria usando Python:

[[example_4_1]]
.Usando Python para confirmar que este ponto está na curva elíptica
====
[source, pycon]
----
Python 3.4.0 (padrão, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatível com Apple LLVM 5.1 (clang-503.0.38)] no darwin
Digite "help", "copyright", "credits" ou "license" para maiores informações.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
>>> (x ** 3 + 7 - y**2) % p
0
----
====

Na matemática de curva elíptica, existe um ponto chamado "ponto no infinito", que de certo modo corresponde ao papel do zero em uma adição. Em computadores, ele às vezes é representado por x = y = 0 (o que não satisfaz a equação da curva elíptica, mas é um caso isolado fácil, que pode ser verificado).

Há também um operador pass:[+], chamado de "adição", que possui algumas propriedades similares à adição tradicional dos números reais que as crianças aprendem no ensino fundamental. Dados dois pontos P~1~ e P~2~ na curva elíptica, há um terceiro ponto P~3~= P~1~ + P~2~, também na curva elíptica.

Geometricamente, esse terceiro ponto P~3~ é calculado ao desenhar-se uma linha entre os pontos P~1~ e P~2~. Essa linha fará a intersecção com a curva elíptica exatamente em um lugar adicional. Chamaremos esse ponto de P~3~' = (x,y). Em seguida, faz-se uma reflexão no eixo x para obter-se o P~3~ = (x, -y).

Existem alguns casos especiais que explicam a necessidade de se ter um "ponto no infinito."

Se P~1~ e P~2~ são o mesmo ponto, a linha "entre" P~1~ e P~2~ deveria estender para ser a tangente na curva no ponto P~1~. Essa tangente fará a intersecção com a curva em um novo ponto exato. Você pode usar técnicas de cálculo para determinar a inclinação da linha tangente. Essas técnicas curiosamente funcionam, mesmo que agora estejamos restringindo nosso interesse para pontos na curva com duas coordenadas de números inteiros!

Em alguns casos (por exemplo, se P~1~ e P~2~ têm os mesmos valores x, mas diferentes valores y), a linha entre P~1~ e P~2~ será exatamente vertical, o que, neste caso, significa que P~3~ = "ponto no infinito".

Se P~1~ é o "ponto no infinito", então P~1~ + P~2~ = P~2~. De modo similar, se P~2~ é o ponto no infinito, então P~1~ + P~2~ = P~1~. Isso mostra como o ponto no infinito faz o papel do zero.

Além disso, o operador pass:[+] é associativo, o que significa que (A pass:[+] B) pass:[+] C = A pass:[+] (B pass:[+] C). Portanto, podemos escrever A pass:[+] B pass:[+] C sem parênteses e sem ambiguidade.

Agora que definimos a adição, podemos definir a multiplicação no modo padrão que estende a adição. Para um ponto P na curva elíptica, se k é um número inteiro, então kP = P + P + P + ... + P (k vezes). Note que o k às vezes é confundido como um "expoente" nesse caso.((("", startref="eliptic04")))((("", startref="Celliptic04")))

[[public_key_derivation]]
==== Gerando uma Chave Pública

((("chaves e endereços", "visão geral das", "geração da chave pública")))((("ponto gerador")))Começando com uma chave privada na forma de um número _k_ gerado aleatoriamente, o multiplicamos por um ponto predeterminado na curva, chamado de _ponto gerador_ _G_, para produzir outro ponto em outro lugar na curva, que será a chave pública _K_ correspondente. O ponto gerador é especificado como parte do padrão +secp256k1+ e é sempre o mesmo para todas as chaves no bitcoin:

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

where _k_ is the private key, _G_ is the generator point, and _K_ is the resulting public key, a point on the curve. Because the generator point is always the same for all bitcoin users, a private key _k_ multiplied with _G_ will always result in the same public key _K_. The relationship between _k_ and _K_ is fixed, but can only be calculated in one direction, from _k_ to _K_. That's why a Bitcoin address (derived from _K_) can be shared with anyone and does not reveal the user's private key (_k_).

[TIP]
====
Uma chave privada pode ser convertida em uma chave pública, mas uma chave pública não pode ser convertida de volta em uma chave privada, pois a matemática só funciona em um único sentido.
====

Implementando a multiplicação de curva elíptica, podemos usar a chave privada _k_ que foi gerada anteriormente e multiplicá-la pelo ponto gerador G para encontrarmos a chave pública _K_:

----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
----

A chave pública _K_ é definida como um ponto +K = (x,y)+:

----
K = (x, y)

onde,

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

Para visualizar a multiplicação de um ponto por um número inteiro, usaremos uma curva elíptica mais simples sobre números reais&#x2014;lembre-se, a matemática é a mesma. Nosso objetivo é encontrar o múltiplo _kG_ de um ponto gerador _G_. Isso é o mesmo que adicionar _G_ a si mesmo, _k_ vezes seguidas. Nas curvas elípticas, adicionar um ponto a si mesmo é o equivalente a desenhar uma linha tangente no ponto, encontrar onde ela intersecciona novamente a curva, e, em seguida, refletir o ponto no eixo x.

A <<ecc_illustrated>> mostra o processo usado para se derivar _G_, _2G_, _4G_ e _8G_ como uma operação geométrica na curva.

[TIP]
====
((("biblioteca C otimizada do secp256k1")))O bitcoin usa a https://github.com/bitcoin-core/secp256k1[biblioteca C otimizada do secp256k1] para fazer a matemática de curva elíptica.((("", startref="KAover04")))
====

[[ecc_illustrated]]
.Criptografia de curva elíptica: visualizando a multiplicação de um ponto G por um número inteiro k em uma curva elíptica
image::images/mbc2_0404.png["ecc_illustrated"]

=== Endereços de Bitcoin

((("keys and addresses", "Bitcoin addresses", id="KAaddress04")))A Bitcoin address is a string of digits and characters that can be shared with anyone who wants to send you money. Addresses produced from public keys consist of a string of numbers and letters, beginning with the digit "1". Here's an example of a Bitcoin address:

----
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
----


The Bitcoin address is what appears most commonly in a transaction as the "recipient" of the funds. If we compare a bitcoin transaction to a paper check, the Bitcoin address is the beneficiary, which is what we write on the line after "Pay to the order of." On a paper check, that beneficiary can sometimes be the name of a bank account holder, but can also include corporations, institutions, or even cash. Because paper checks do not need to specify an account, but rather use an abstract name as the recipient of funds, they are very flexible payment instruments. Bitcoin transactions use a similar abstraction, the Bitcoin address, to make them very flexible. A Bitcoin address can represent the owner of a private/public key pair, or it can represent something else, such as a payment script, as we will see in <<p2sh>>. For now, let's examine the simple case, a Bitcoin address that represents, and is derived from, a public key.

((("addresses", "algorithms used to create")))The Bitcoin address is derived from the public key through the use of one-way cryptographic hashing. A "hashing algorithm" or simply "hash algorithm" is a one-way function that produces a fingerprint or "hash" of an arbitrary-sized input. Cryptographic hash functions are used extensively in bitcoin: in Bitcoin addresses, in script addresses, and in the mining Proof-of-Work algorithm. The algorithms used to make a Bitcoin address from a public key are the Secure Hash Algorithm (SHA) and the RACE Integrity Primitives Evaluation Message Digest (RIPEMD), specifically SHA256 and RIPEMD160.

Iniciando com a chave pública _K_, computamos o hash SHA256, e depois computamos o hash RIPEMD160 do resultado, produzindo um número de 160 bits (20 bytes):

[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++

where _K_ is the public key and _A_ is the resulting Bitcoin address.


[TIP]
====
A Bitcoin address is _not_ the same as a public key. Bitcoin addresses are derived from a public key using a one-way function.
====

Bitcoin addresses are almost always encoded as "Base58Check" (see <<base58>>), which uses 58 characters (a Base58 number system) and a checksum to help human readability, avoid ambiguity, and protect against errors in address transcription and entry. Base58Check is also used in many other ways in bitcoin, whenever there is a need for a user to read and correctly transcribe a number, such as a Bitcoin address, a private key, an encrypted key, or a script hash. In the next section we will examine the mechanics of Base58Check encoding and decoding and the resulting representations. <<pubkey_to_address>> illustrates the conversion of a public key into a Bitcoin address.

[[pubkey_to_address]]
.Public key to Bitcoin address: conversion of a public key into a Bitcoin address
image::images/mbc2_0405.png["pubkey_to_address"]

[[base58]]
==== Codificação Base58 e Base58Check

((("keys and addresses", "Bitcoin addresses", "Base58 and Base58check encoding")))((("Base58 and Base58check encoding", id="base5804")))((("addresses", "Base58 and Base58check encoding", id="Abase5804")))In order to represent long numbers in a compact way, using fewer symbols, many computer systems use mixed-alphanumeric representations with a base (or radix) higher than 10. For example, whereas the traditional decimal system uses the 10 numerals 0 through 9, the hexadecimal system uses 16, with the letters A through F as the six additional symbols. A number represented in hexadecimal format is shorter than the equivalent decimal representation. Even more compact, Base64 representation uses 26 lowercase letters, 26 capital letters, 10 numerals, and 2 more characters such as &#x201c;`+`&#x201d; and "/" to transmit binary data over text-based media such as email. Base64 is most commonly used to add binary attachments to email. Base58 is a text-based binary-encoding format developed for use in bitcoin and used in many other cryptocurrencies. It offers a balance between compact representation, readability, and error detection and prevention. Base58 is a subset of Base64, using upper- and lowercase letters and numbers, but omitting some characters that are frequently mistaken for one another and can appear identical when displayed in certain fonts. Specifically, Base58 is Base64 without the 0 (number zero), O (capital o), l (lower L), I (capital i), and the symbols &#x201c;`+`&#x201d; and "/". Or, more simply, it is a set of lowercase and capital letters and numbers without the four (0, O, l, I) just mentioned. <<base58alphabet>> shows the full Base58 alphabet.

[[base58alphabet]]
.Alfabeto Base58 do Bitcoin
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====


To add extra security against typos or transcription errors, Base58Check is a Base58 encoding format, frequently used in bitcoin, which has a built-in error-checking code. The checksum is an additional four bytes added to the end of the data that is being encoded. The checksum is derived from the hash of the encoded data and can therefore be used to detect and prevent transcription and typing errors. When presented with Base58Check code, the decoding software will calculate the checksum of the data and compare it to the checksum included in the code. If the two do not match, an error has been introduced and the Base58Check data is invalid. This prevents a mistyped Bitcoin address from being accepted by the wallet software as a valid destination, an error that would otherwise result in loss of funds.

To convert data (a number) into a Base58Check format, we first add a prefix to the data, called the "version byte," which serves to easily identify the type of data that is encoded. For example, in the case of a Bitcoin address the prefix is zero (0x00 in hex), whereas the prefix used when encoding a private key is 128 (0x80 in hex). A list of common version prefixes is shown in <<base58check_versions>>.

A seguir, computamos o _checksum_ do "duplo-SHA", o que significa que aplicamos o algoritmo de hash SHA256 duas vezes no resultado anterior (prefixo e dados):

----
checksum = SHA256(SHA256(prefixo+dados))
----

Pegamos apenas os primeiros quatro bytes do hash de 32 bytes resultante (hash do hash). Esses quatro bytes iniciais servem como código de verificação de erro, ou _checksum_. O _checksum_ é concatenado (acrescentado) ao final.

O resultado é composto de três itens: um prefixo, os dados e um _checksum_. Esse resultado é codificado usando o alfabeto Base58 descrito previamente. A <<base58check_encoding>> ilustra o processo de codificação em Base58Check.

[[base58check_encoding]]
.Codificação em Base58Check: um formato para codificar dados do bitcoin de maneira inequívoca, versionada e verificada.
image::images/mbc2_0406.png["Base58CheckEncoding"]

In bitcoin, most of the data presented to the user is Base58Check-encoded to make it compact, easy to read, and easy to detect errors. The version prefix in Base58Check encoding is used to create easily distinguishable formats, which when encoded in Base58 contain specific characters at the beginning of the Base58Check-encoded payload. These characters make it easy for humans to identify the type of data that is encoded and how to use it. This is what differentiates, for example, a Base58Check-encoded Bitcoin address that starts with a 1 from a Base58Check-encoded private key WIF that starts with a 5. Some example version prefixes and the resulting Base58 characters are shown in <<base58check_versions>>.

[[base58check_versions]]
.Prefixos de versão da Base58Check e exemplos de resultados codificados
[options="header"]
|=======
|Tipo| Prefixo de versão (hex)| Prefixo em Base58 (resultado)
| Endereço de Bitcoin | 0x00 | 1
| Endereço Pay-to-Script-Hash | 0x05 | 3
| Endereço da Testnet do Bitcoin | 0x6F | m ou n
| Chave Privada WIF |  0x80 | 5, K ou L
| Chave Privada Criptografada da BIP-38 | 0x0142 | 6P
| Chave Pública Estendida da BIP-32 | 0x0488B21E | xpub
|=======

==== Formatos de Chave

((("keys and addresses", "Bitcoin addresses", "key formats")))Both private and public keys can be represented in a number of different formats. These representations all encode the same number, even though they look different. These formats are primarily used to make it easy for people to read and transcribe keys without introducing errors.

[[priv_formats]]
===== Formatos de chave privada

((("chaves públicas e privadas", "formatos de chave privada")))A chave privada pode ser representada em vários formatos diferentes, todos correspondendo ao mesmo número de 256 bits. A <<table_4-2>> mostra três formatos comumente usados para representar chaves privadas. Diferentes formatos são usados em diferentes circunstâncias. Os formatos hexadecimal e binário bruto são usados internamente no software e raramente são exibidos aos usuários. O formato WIF é usado para importar/exportar chaves entre carteiras e é frequentemente usado em representações de chaves privadas em código QR (código de barras).

[[table_4-2]]
.Representações de chave privada (formatos de codificação)
[options="header"]
|=======
|Tipo|Prefixo|Descrição
| Bruto (_raw_) | Nenhum | 32 bytes
| Hex | Nenhum | 64 dígitos hexadecimais
| WIF |  5 | Codificação em Base58Check: Base58 com prefixo de versão 0x80 e _checksum_ de 4 bytes
| WIF-comprimida | K ou L | Como acima, com a adição do sufixo 0x01 antes da codificação
|=======

A <<table_4-3>> demonstra a chave privada gerada nesses três formatos de codificação.

[[table_4-3]]
.Exemplo: A mesma chave, em diferentes formatos de codificação
[options="header"]
|=======
|Formato | Chave privada
| Hex | 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| WIF-comprimida | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

Todas essas representações são diferentes maneiras de se exibir o mesmo número, a mesma chave privada. Elas aparentam ser diferentes, mas qualquer um desses formatos pode ser facilmente convertido para qualquer outro formato. Observe que o "binário bruto" não é mostrado na <<table_4-3>>, pois qualquer codificação para exibição aqui não seria considerada, por definição, um dado binário bruto.

Usamos o comando +wif-to-ec+ do Bitcoin Explorer (ver o <<appdx_bx>>) para demonstrar que ambas as chaves WIF representam a mesma chave privada:

----
$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
----

===== Decodificando do Base58Check

Os comandos do Bitcoin Explorer (ver o <<appdx_bx>>) tornam fácil a escrita de scripts em shell e _pipes_ de linha de comando que manipulam chaves, endereços e transações de bitcoin. Você pode usar o Bitcoin Explorer para decodificar o formato Base58Check na linha de comando.

Usamos o comando +base58check-decode+ para decodificar a chave não comprimida:

----
$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}
----

O resultado contém a chave como corpo de dados (_payload_), o prefixo de versão 128 da WIF e um _checksum_.

Note que o corpo de dados (_payload_) da chave privada comprimida é acrescido com o sufixo +01+, sinalizando que a chave pública derivada deve ser comprimida:

----
$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}
----

====== Codificando de hex para Base58Check

Para codificar em Base58Check (o oposto do comando anterior), usamos o comando +base58check-encode+ do Bitcoin Explorer (ver <<appdx_bx>>) e fornecemos a chave privada em hexadecimal, seguida pelo prefixo de versão 128 do WIF:

----
bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

===== Codificando de hex (chave comprimida) para Base58Check

Para codificar em Base58Check como uma chave privada "comprimida" (ver <<comp_priv>>), concatenamos o sufixo +01+ à chave hexadecimal e em seguida codificamos conforme descrito na seção anterior:

----
$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

O formato WIF-comprimida resultante começa com um "K". Isso denota que a chave privada contida tem um sufixo "01" e será usada para produzir apenas chaves públicas comprimidas (ver <<comp_pub>>).

===== Formatos de chave pública

((("chaves públicas e privadas", "formatos de chave pública")))As chaves públicas também são apresentadas de diferentes maneiras, geralmente como chaves públicas _comprimidas_ ou _não comprimidas_.

Conforme vimos anteriormente, a chave pública é um ponto na curva elíptica que consiste em um par de coordenadas +(x,y)+. Ela geralmente é apresentada com o prefixo +04+ seguido por dois números de 256 bits, um para a coordenada _x_ do ponto, e o outro para a coordenada _y_. O prefixo +04+ é usado para distinguir as chaves públicas não comprimidas das chaves públicas comprimidas que começam com +02+ ou +03+.

Aqui está a chave pública gerada pela chave privada que criamos anteriormente, mostrada como as coordenadas +x+ e +y+:

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

Aqui está a mesma chave pública mostrada como um número de 520 bits (130 dígitos hexadecimais) com o prefixo +04+ seguido pelas coordenadas +x+ e +y+, como +04 x y+:

++++
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&#x21b5;
07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
++++

[[comp_pub]]
===== Chaves públicas comprimidas

((("public and private keys", "compressed public keys")))Compressed public keys were introduced to bitcoin to reduce the size of transactions and conserve disk space on nodes that store the Bitcoin blockchain database. Most transactions include the public key, which is required to validate the owner's credentials and spend the bitcoin. Each public key requires 520 bits (prefix + x + y), which when multiplied by several hundred transactions per block, or tens of thousands of transactions per day, adds a significant amount of data to the blockchain.

Conforme vimos na seção <<pubkey>>, uma chave pública é um ponto (x,y) em uma curva elíptica. Como a curva expressa uma função matemática, um ponto na curva representa uma solução para a equação e, portanto, se soubermos a coordenada _x_, podemos calcular a coordenada _y_ ao resolver a equação y^2^ mod p = (x^3^ + 7) mod p. Isso nos permite armazenar somente a coordenada _x_ do ponto da chave pública, omitindo a coordenada _y_ e reduzindo o tamanho da chave e o espaço necessário para armazená-la em 256 bits. Uma redução de quase 50% no tamanho de cada transação economiza a utilização de muito espaço ao longo do tempo!

Enquanto as chaves públicas não comprimidas tem o prefixo +04+, as chaves públicas comprimidas começam com os prefixos +02+ ou +03+. Existe um motivo pelo qual só existem dois prefixos possíveis: como o lado esquerdo da equação é __y__^2^, a solução para _y_ é uma raiz quadrada, que pode ter um valor positivo ou negativo. Visualmente, isso significa que a coordenada _y_ resultante pode estar acima ou abaixo do eixo x. Como você pode ver no gráfico da curva elíptica na <<ecc-curve>>, a curva é simétrica, sendo refletida pelo eixo x, como se fosse um espelho. Então, embora podemos omitir a coordenada _y_, temos que armazenar o _sinal_ do _y_ (positivo ou negativo); ou, em outras palavras, temos que nos lembrar se ela estava acima ou abaixo do eixo x, pois cada uma dessas opções representa um ponto diferente e uma chave pública diferente. Quando se calcula a curva elíptica em aritmética binária no corpo finito de ordem prima p, a coordenada _y_ ou é par ou é ímpar, o que corresponde ao sinal positivo/negativo como explicado anteriormente. Portanto, para distinguir entre os dois valores possíveis de _y_, armazenamos a chave pública comprimida com o prefixo +02+ se o _y_ for par, e +03+ se ele for ímpar, permitindo que o software deduza corretamente a coordenada _y_ a partir da coordenada _x_ e descomprima a chave pública para as coordenadas completas do ponto. A compressão de chave pública é ilustrada na <<pubkey_compression>>.

Aqui está a mesma chave pública gerada anteriormente, exibida como uma chave pública comprimida armazenada em 264 bits (66 dígitos hexadecimais) com o prefixo +03+ indicando que a coordenada _y_ é ímpar:

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

This compressed public key corresponds to the same private key, meaning it is generated from the same private key. However, it looks different from the uncompressed public key. More importantly, if we convert this compressed public key to a Bitcoin address using the double-hash function (+RIPEMD160(SHA256(K))+) it will produce a _different_ Bitcoin address. This can be confusing, because it means that a single private key can produce a public key expressed in two different formats (compressed and uncompressed) that produce two different Bitcoin addresses. However, the private key is identical for both Bitcoin addresses.

[[pubkey_compression]]
[role="smallerseventy"]
.Compressão de chave pública
image::images/mbc2_0407.png["pubkey_compression"]

Compressed public keys are gradually becoming the default across Bitcoin clients, which is having a significant impact on reducing the size of transactions and therefore the blockchain. However, not all clients support compressed public keys yet. Newer clients that support compressed public keys have to account for transactions from older clients that do not support compressed public keys. This is especially important when a wallet application is importing private keys from another bitcoin wallet application, because the new wallet needs to scan the blockchain to find transactions corresponding to these imported keys. Which Bitcoin addresses should the bitcoin wallet scan for? The Bitcoin addresses produced by uncompressed public keys, or the Bitcoin addresses produced by compressed public keys? Both are valid Bitcoin addresses, and can be signed for by the private key, but they are different addresses!

To resolve this issue, when private keys are exported from a wallet, the WIF that is used to represent them is implemented differently in newer bitcoin wallets, to indicate that these private keys have been used to produce _compressed_ public keys and therefore _compressed_ Bitcoin addresses. This allows the importing wallet to distinguish between private keys originating from older or newer wallets and search the blockchain for transactions with Bitcoin addresses corresponding to the uncompressed, or the compressed, public keys, respectively. Let's look at how this works in more detail, in the next section.

[[comp_priv]]
===== Chaves privadas comprimidas

((("chaves públicas e privadas", "chaves privadas comprimidas")))Ironicamente, o termo "chave privada comprimida" não é um nome muito preciso, pois quando uma chave privada é exportada como WIF-comprimida, ela é na verdade um byte _maior_ do que uma chave privada "não comprimida". Isso acontece porque a chave privada tem um sufixo adicional de um byte (mostrado como 01 no hexadecimal na <<table_4-4>>), o que significa que a chave privada é de uma carteira moderna e só deve ser usada para produzir chaves públicas comprimidas. As chaves privadas em si não são comprimidas e não há como comprimi-las. O que o termo "chave privada comprimida" realmente significa é "chave privada a partir da qual somente chaves públicas comprimidas devem ser derivadas", enquanto o que o termo "chave privada não comprimida" realmente significa é "chave privada a partir da qual somente chaves públicas não comprimidas devem ser derivadas". É recomendado que você se refira ao formato de exportação apenas como "WIF-comprimida" ou "WIF" e, para evitar maiores confusões, que você evite se referir à chave privada em si como "comprimida".

A <<table_4-4>> mostra a mesma chave, codificada nos formatos WIF e WIF-comprimida.

[[table_4-4]]
.Exemplo: A mesma chave, em diferentes formatos de codificação
[options="header"]
|=======
|Formato | Chave privada
| Hex | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| Hex-comprimida | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01
| WIF-comprimida | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

Observe que a chave privada hex-comprimida tem um byte extra no final (01 em hexadecimal). Embora o prefixo de versão da Base58Check seja o mesmo (0x80) para os formatos WIF e WIF-comprimida, a adição de um byte no final do número faz com que o primeiro caractere da codificação Base58 mude de 5 para _K_ ou _L_. Pense nisso como sendo o equivalente Base58 da diferença de codificação decimal entre o número 100 e o número 99. Embora 100 seja um dígito mais longo que 99, ele também tem um prefixo 1 ao invés de um prefixo 9. À medida que o comprimento muda, isso afeta o prefixo. Na Base58, o prefixo 5 muda para _K_ ou _L_ conforme o comprimento do número aumenta em um byte.

Lembre-se de que esses formatos _não são_ intercambiáveis. Em uma carteira moderna que implementa chaves públicas comprimidas, as chaves privadas só serão exportadas como WIF-comprimidas (com um prefixo _K_ ou _L_). Se a carteira tiver uma implementação mais antiga e não usar chaves públicas comprimidas, as chaves privadas só serão exportadas como WIF (com um prefixo 5). O objetivo disso é sinalizar para a carteira que está importando essas chaves privadas se ela precisa pesquisar na blockchain por chaves públicas e endereços comprimidos ou não comprimidos.

If a bitcoin wallet is able to implement compressed public keys, it will use those in all transactions. The private keys in the wallet will be used to derive the public key points on the curve, which will be compressed. The compressed public keys will be used to produce Bitcoin addresses and those will be used in transactions. When exporting private keys from a new wallet that implements compressed public keys, the WIF is modified, with the addition of a one-byte suffix +01+ to the private key. The resulting Base58Check-encoded private key is called a "compressed WIF" and starts with the letter _K_ or _L_, instead of starting with "5" as is the case with WIF-encoded (noncompressed) keys from older wallets.


[TIP]
====
"Compressed private keys" is a misnomer! They are not compressed; rather, WIF-compressed signifies that the keys should only be used to derive compressed public keys and their corresponding Bitcoin addresses. Ironically, a "WIF-compressed" encoded private key is one byte longer because it has the added +01+ suffix to distinguish it from an "uncompressed" one.((("", startref="KAaddress04")))
====

=== Implementando Chaves e Endereços em Cpass:[++]

Let's look at the complete process of creating a Bitcoin address, from a private key, to a public key (a point on the elliptic curve), to a double-hashed address, and finally, the Base58Check encoding. The C++ code in <<addr_example>> shows the complete step-by-step process, from private key to Base58Check-encoded Bitcoin address. The code example uses the libbitcoin library introduced in <<alt_libraries>> for some helper functions.

[[addr_example]]
.Creating a Base58Check-encoded Bitcoin address from a private key
====
[role="c_less_space"]
[source, cpp]
----
include::code/addr.cpp[]
----
====

The code uses a predefined private key to produce the same Bitcoin address every time it is run, as shown in <<addr_example_run>>.((("", startref="base5804")))((("", startref="Abase5804")))

[[addr_example_run]]
.Compilando e executando o código addr.cpp
====
[source,bash]
----
# Compila o código addr.cpp
$ g++ -o addr addr.cpp -std=c++11 $(pkg-config --cflags --libs libbitcoin)
# Roda o executável addr
$ ./addr
Chave pública: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
Endereço: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK
----
====

[TIP]
====
The code in <<addr_example_run>> produces a Bitcoin address (+1PRTT...+) from a _compressed_ public key (see <<comp_pub>>). If you used the uncompressed public key instead, it would produce a different Bitcoin address (+14K1y...+).
====

=== Implementando Chaves e Endereços em Python

((("chaves e endereços", "implementando em Python", id="KApython04")))((("pybitcointools")))A biblioteca de bitcoin mais completa em Python é a https://github.com/vbuterin/pybitcointools[pybitcointools] feita por Vitalik Buterin. No <<key-to-address_script>>, usamos a biblioteca pybitcointools (importada como "bitcoin") para gerar e exibir chaves e endereços em vários formatos.

[[key-to-address_script]]
.Geração e formatação de chaves e endereços com a biblioteca pybitcointools
====
[source,python]
----
include::code/key-to-address-ecc-example.py[]
----
====

O <<key-to-address_script_run>> mostra o output após executar esse código.

[[key-to-address_script_run]]
.Executando key-to-address-ecc-example.py
====
++++
<pre data-type="programlisting">
$ python key-to-address-ecc-example.py
A Chave Privada (hex) é:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
A Chave Privada (decimal) é:
 26563230048437957592232553826663696440606756685920117476832299673293013768870
A Chave Privada (WIF) é:
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
A Chave Privada Comprimida (hex) é:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
A Chave Privada (WIF-Comprimida) é:
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
A Chave Pública em coordenadas (x,y) é:
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L,
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
A Chave Pública (hex) é:
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec&#x21b5;
243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
A Chave Pública Comprimida (hex) é:
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
O Endereço de Bitcoin (b58check) é:
 1thMirt546nngXqyPEz532S8fLwbozud8
O Endereço de Bitcoin Comprimido (b58check) é:
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</pre>
++++
====


O <<ec_math>> é outro exemplo, que usa a biblioteca Python de ECDSA para a matemática de curva elíptica e não usa nenhuma biblioteca especializada de bitcoin.

[[ec_math]]
.Um script demonstrado a matemática de curva elíptica usada para as chaves do bitcoin
====
[source, python]
----
include::code/ec-math.py[]
----
====

O <<ec_math_run>> mostra a saída produzida ao executar-se esse script.

[WARNING]
====
O <<ec_math>> ((("números aleatórios", "os.urandom", see="entropy")))((("entropia", "os.urandom", see="números aleatórios")))((("números aleatórios", "geração de número aleatório")))((("entropia", "geração de número aleatório")))usa o +os.urandom+, que reflete um gerador de número aleatório criptograficamente seguro (CSRNG) fornecido pelo sistema operacional subjacente. Cuidado: dependendo do sistema operacional, é possível que o +os.urandom+ _não_ seja implementado com segurança suficiente ou que ele não use uma semente aleatória adequada e, em função disso, pode ser que ele _não_ seja apropriado para gerar chaves de bitcoin com qualidade suficiente para serem usadas em produção.((("", startref="KApython04")))
====

[[ec_math_run]]
.Instalando a biblioteca Python de ECDSA e executando o script ec_math.py
====
----
# Instala o administrador de pacotes Python PIP
$ sudo apt-get install python-pip
# Instala a biblioteca Python de ECDSA
$ sudo pip install ecdsa
# Executa o script
$ python ec-math.py
Segredo: 38090835015954358862481132628887443905906204995912378278060168703580660294000
Ponto na CE: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
Chave pública do BTC: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873
----
====

=== Chaves e Endereços Avançados

((("chaves e endereços", "formas avançadas", id="KAadvanced04")))Nas próximas seções, veremos as formas avançadas de chaves e endereços, como chaves privadas criptografadas, scripts e endereços multiassinatura, endereços personalizados e carteiras de papel.

[[p2sh_addresses]]
==== Endereços Pay-to-Script Hash (P2SH) e Multiassinatura

((("keys and addresses", "advanced forms", "pay-to-script hash and multisig addresses")))((("Pay-to-Script-Hash (P2SH)", "multisig addresses and")))((("multisig addresses")))((("addresses", "multisig addresses")))As we know, traditional Bitcoin addresses begin with the number “1” and are derived from the public key, which is derived from the private key.  Although anyone can send bitcoin to a “1” address, that bitcoin can only be spent by presenting the corresponding private key signature and public key.

((("bitcoin improvement proposals", "Pay to Script Hash (BIP-16)")))Bitcoin addresses that begin with the number “3” are pay-to-script hash (P2SH) addresses, sometimes erroneously called multisignature or multisig addresses. They designate the beneficiary of a bitcoin transaction as the hash of a script, instead of the owner of a public key. The feature was introduced in January 2012 with BIP-16 (see <<appdxbitcoinimpproposals>>), and is being widely adopted because it provides the opportunity to add functionality to the address itself. Unlike transactions that "send" funds to traditional “1” Bitcoin addresses, also known as a pay-to-public-key-hash (P2PKH), funds sent to “3” addresses require something more than the presentation of one public key and one private key signature as proof of ownership. The requirements are designated at the time the address is created, within the script, and all inputs to this address will be encumbered with the same requirements.

A P2SH address is created from a transaction script, which defines who can spend a transaction output (for more details, see <<p2sh>>). Encoding a P2SH address involves using the same double-hash function as used during creation of a Bitcoin address, only applied on the script instead of the public key:

----
hash do script = RIPEMD160(SHA256(script))
----

O "hash de script" resultante é codificado em Base58Check com um prefixo de versão 5, que resulta em um endereço codificado que inicia com um +3+. Um exemplo de endereço P2SH é +3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM+, que pode ser derivado usando-se os comandos +script-encode+, +sha256+, +ripemd160+ e +base58check-encode+ do Bitcoin Explorer (ver o <<appdx_bx>>), como demonstrado a seguir:

----
$ echo \
'DUP HASH160 [89abcdefabbaabbaabbaabbaabbaabbaabbaabba] EQUALVERIFY CHECKSIG' > script
$ bx script-encode < script | bx sha256 | bx ripemd160 \
| bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM
----

[TIP]
====
P2SH não necessariamente é o mesmo que uma transação multiassinatura padrão. Um endereço P2SH _geralmente_ representa um script multiassinatura, mas ele também pode representar um script codificando outros tipos de transações.
====

===== Endereços multiassinatura e P2SH

Atualmente, a implementação mais comum da função P2SH é o script de endereço multiassinatura. Como o nome sugere, o script subjacente exige um número mínimo de assinaturas para provar a posse e, portanto, gastar os fundos. A funcionalidade de multiassinatura do bitcoin é projetada para exigir M assinaturas (também conhecidas como o "limiar", em inglês, _threshold_) de um total de N chaves, o que é conhecido como uma multiassinatura M-de-N, onde M é igual ou menor do que N. Por exemplo, Bob, o dono da cafeteria do <<ch01_intro_what_is_bitcoin>> poderia usar um endereço multiassinatura exigindo 1-de-2 assinaturas geradas a partir da chave que o pertence e de uma chave que pertence à sua esposa, garantindo que qualquer um deles poderia fazer uma assinatura para gastar uma saída de transação travada nesse endereço. Isso seria semelhante a uma "conta conjunta" em um banco tradicional, onde qualquer um dos cônjuges pode gastar sozinho com a sua própria assinatura. Ou o Gopesh,((("casos de uso", "serviços de contrato offshore"))) o web designer que o Bob contratou para criar um site, poderia ter um endereço multiassinatura 2-de-3 para o seu negócio, para garantir que nenhum fundo possa ser gasto a menos que dois de seus sócios assinem uma transação.

Exploraremos como criar transações que gastam fundos de endereços P2SH (e multiassinatura) no <<transactions>>.

==== Endereços Personalizados

((("keys and addresses", "advanced forms", "vanity addresses")))((("vanity addresses", id="vanity04")))((("addresses", "vanity addresses", id="Avanity04")))Vanity addresses are valid Bitcoin addresses that contain human-readable messages. For example, +1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33+ is a valid address that contains the letters forming the word "Love" as the first four Base58 letters. Vanity addresses require generating and testing billions of candidate private keys, until a Bitcoin address with the desired pattern is found. Although there are some optimizations in the vanity generation algorithm, the process essentially involves picking a private key at random, deriving the public key, deriving the Bitcoin address, and checking to see if it matches the desired vanity pattern, repeating billions of times until a match is found.

Assim que um endereço personalizado correspondendo ao padrão desejado for encontrado, a chave privada da qual ele foi derivado pode ser usada pelo dono para gastar os bitcoins da mesma maneira como se fosse qualquer outro endereço. Os endereços personalizados não são mais ou menos seguros do que qualquer outro endereço. Eles dependem da mesma Criptografia de Curva Elíptica (ECC) e do mesmo Algoritmo de Hash Seguro (SHA) como qualquer outro endereço. Não é mais fácil descobrir a chave privada de um endereço que começa com um padrão personalizado, em comparação com qualquer outro endereço.

In <<ch01_intro_what_is_bitcoin>>, we introduced Eugenia, a children's charity director operating in the Philippines. Let's say that Eugenia is organizing a bitcoin fundraising drive and wants to use a vanity Bitcoin address to publicize the fundraising. Eugenia will create a vanity address that starts with "1Kids" to promote the children's charity fundraiser. Let's see how this vanity address will be created and what it means for the security of Eugenia's charity.((("use cases", "charitable donations", startref="eugeniafour")))

===== Gerando endereços personalizados

It's important to realize that a Bitcoin address is simply a number represented by symbols in the Base58 alphabet. The search for a pattern like "1Kids" can be seen as searching for an address in the range from +1Kids11111111111111111111111111111+ to +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+. There are approximately 58^29^ (approximately 1.4 * 10^51^) addresses in that range, all starting with "1Kids." <<table_4-11>> shows the range of addresses that have the prefix 1Kids.

[[table_4-11]]
.O intervalo de endereços personalizados iniciando com "1Kids"
|=======
| *De* | +1Kids11111111111111111111111111111+
| | +1Kids11111111111111111111111111112+
| | +1Kids11111111111111111111111111113+
| | +...+
| *Até* | +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+
|=======

Let's look at the pattern "1Kids" as a number and see how frequently we might find this pattern in a Bitcoin address (see <<table_4-12>>). An average desktop computer PC, without any specialized hardware, can search approximately 100,000 keys per second.

[[table_4-12]]
.A frequência de um padrão personalizado (1KidsCharity) e o tempo médio de busca em um computador desktop
[options="header"]
|=======
| Comprimento | Padrão | Frequência | Tempo médio de busca
| 1 | 1K | 1 em 58 chaves | < 1 milissegundo
| 2 | 1Ki| 1 em 3.364 | 50 milissegundos
| 3 | 1Kid | 1 em 195.000 | < 2 segundos
| 4 | 1Kids | 1 em 11 milhões | 1 minuto
| 5 | 1KidsC | 1 em 656 milhões | 1 hora
| 6 | 1KidsCh | 1 em 38 bilhões | 2 dias
| 7 | 1KidsCha | 1 em 2,2 trilhões | 3–4 meses
| 8 | 1KidsChar | 1 em 128 trilhões | 13–18 anos
| 9 | 1KidsChari | 1 em 7 quadrilhões | 800 anos
| 10 | 1KidsCharit | 1 em 400 quadrilhões | 46.000 anos
| 11 | 1KidsCharity | 1 em 23 quintilhões | 2,5 milhões de anos
|=======


Como você pode ver, a Eugênia não conseguirá criar o endereço personalizado "1KidsCharity" tão cedo, mesmo que ela tivesse acesso a milhares de computadores. Cada caractere adicional aumenta a dificuldade em um fator de 58. Os padrões de sete ou mais caracteres geralmente são encontrados utilizando-se hardware especializado, como desktops montados de maneira customizada com múltiplas placas de vídeo (GPUs). Esses hardwares frequentemente são equipamentos antigos que já foram usados para a mineração do bitcoin e que não são mais lucrativos para esse propósito, mas que ainda podem ser usados para buscar endereços personalizados. As buscas por endereços personalizados em sistemas usando placas de vídeo (GPUs) são várias ordens de magnitude mais rápidas do que as realizadas em sistemas usando processadores de propósito geral (CPUs).

Outra maneira de encontrar um endereço personalizado é terceirizar o trabalho para uma pool vanity de mineradores, como a https://vanitypool.appspot.com[Vanity Pool]. Uma pool desse tipo é um serviço que permite que aqueles com hardware de GPU ganhem bitcoin procurando endereços personalizados para os outros. Por um pequeno pagamento (0,01 bitcoin ou aproximadamente USD $5 no momento da redação deste artigo), a Eugenia pode terceirizar a pesquisa por um endereço personalizado com padrão de sete caracteres e obter resultados em algumas horas, em vez que executar uma pesquisa usando uma CPU levaria meses.

A geração de um endereço personalizado é um exercício de força bruta: crie uma chave aleatória, verifique se o endereço resultante corresponde ao padrão desejado e repita o processo até encontrar um endereço que corresponda. O <<vanity_miner_code>> mostra um exemplo de um "minerador de endereço personalizado" (em inglês, _vanity miner_), um programa projetado para buscar endereços personalizados, escrito em C++. O exemplo usa a biblioteca libbitcoin, que apresentamos em <<alt_libraries>>.

[[vanity_miner_code]]
.Minerador de endereço personalizado
====
[source,cpp]
----
include::code/vanity-miner.cpp[]
----
====

[NOTE]
====
O <<vanity_miner_code>> usa o +std::random_device+. Dependendo da implementação, ele pode refletir um gerador de número aleatório criptograficamente seguro fornecido pelo sistema operacional subjacente. No caso de um sistema operacional do tipo Unix, como o Linux, ele é obtido a partir do +/dev/urandom+. O gerador de número aleatório utilizado aqui é usado apenas para fins de demonstração e _não_ é apropriado para gerar chaves de bitcoin com qualidade para serem usadas em produção, pois ele não é implementado com segurança suficiente.
====

O código de exemplo deve ser compilado usando um compilador pass:[C++] e vinculado à biblioteca libbitcoin (que deve ser previamente instalada no sistema). Para executar o exemplo, rode o executável ++vanity-miner++ sem nenhum parâmetro (ver o <<vanity_miner_run>>) e ele tentará encontrar um endereço personalizado que inicie com "1kid".

[[vanity_miner_run]]
.Compilando e executando o exemplo _vanity-miner_
====
[source,bash]
----
# Compila o código com g++
$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
# Executa o exemplo
$ ./vanity-miner
Endereço personalizado encontrado! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
Segredo: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
# Executa o exemplo novamente para se obter um resultado diferente
$ ./vanity-miner
Endereço personalizado encontrado! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
Segredo: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
# Usa "time" para ver quanto tempo demora para se encontrar um resultado
$ time ./vanity-miner
Endereço personalizado encontrado! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
Segredo: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

real	0m8.868s
user	0m8.828s
sys	0m0.035s
----
====

O código de exemplo levará alguns segundos para encontrar uma correspondência ao padrão de três caracteres "kid", como podemos ver quando usamos o comando +time+ do Unix para medir o tempo de execução. Mude o padrão desejado alterando a _string_ +search+ no código-fonte e veja o quão demorado é para se conseguir encontrar padrões de quatro ou cinco caracteres!

===== Segurança do endereço personalizado

((("segurança", "endereços personalizados")))Os endereços personalizados podem ser usados tanto para melhorar _quanto_ para burlar medidas de segurança; eles são uma verdadeira faca de dois gumes. Quando usado para melhorar a segurança, um endereço diferenciado torna mais difícil para que hackers substituam o seu endereço pelo endereço deles, o que faria com que seus clientes pagassem para os hackers, ao invés de pagarem para você. Infelizmente, os endereços personalizados também permitem que qualquer pessoa crie um endereço que se _pareça_ com qualquer endereço aleatório, ou mesmo outro endereço personalizado, e com isso enganando seus clientes.

A Eugênia poderia divulgar um endereço gerado aleatoriamente (por exemplo, +1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+) para que as pessoas enviem suas doações. Ou ela poderia gerar um endereço personalizado que começa com 1Kids, para torná-lo mais atraente.

Em ambos os casos, um dos riscos de se usar um endereço fixo único (em vez de usar um endereço dinâmico separado para cada doador) é que um ladrão pode conseguir invadir o seu site e substituir o seu endereço pelo endereço dele, desviando as doações que você receberia. Se você divulgou seu endereço de doação em vários lugares diferentes, seus usuários podem inspecionar visualmente o endereço antes de fazer um pagamento, para se assegurarem que ele é o mesmo que eles viram em seu site, e-mail ou flyer. No caso de um endereço aleatório como +1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+, o usuário comum talvez inspecionará apenas os primeiros caracteres "1J7mdg" e ficará satisfeito se eles forem iguais. Usando um gerador de endereços personalizados, uma pessoa mal-intencionada pode criar rapidamente endereços que se pareçam com o verdadeiro, com apenas os primeiros caracteres iguais, como demonstrado na <<table_4-13>>.

[[table_4-13]]
.Gerando endereços personalizados para corresponder a um endereço aleatório
|=======
| *Endereço Aleatório Original* | 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
| *Endereço Personalizado (4 caracteres)* | 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy
| *Endereço Personalizado (5 caracteres)* | 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n
| *Endereço Personalizado (6 caracteres)* | 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX
|=======

Então um endereço personalizado aumenta a segurança? Se a Eugênia gerar o endereço personalizado +1Kids33q44erFfpeXrmDSz7zEqG2FesZEN+, os usuários provavelmente olharão para a palavra com o padrão personalizado _e alguns caracteres além_, por exemplo, percebendo a parte "1Kids33" do endereço. Isso forçaria um hacker a gerar um endereço personalizado que tenha pelo menos seis caracteres iguais (dois a mais), tendo que se esforçar 3.364 vezes mais (58 &#x00D7; 58) do que a Eugênia teve que se esforçar para conseguir gerar o seu endereço personalizado de quatro caracteres. Essencialmente, o esforço que a Eugênia teve que fazer (ou pagar para uma pool de mineração fazer) acaba exigindo que o hacker produza um padrão personalizado mais longo. Se a Eugênia pagar para uma pool gerar um endereço personalizado de 8 caracteres, o hacker teria que fazer um esforço para produzir um endereço de 10 caracteres, algo que é inviável de ser feito em um computador pessoal e muito caro para ser obtido, até mesmo em equipamentos de mineração de endereços personalizados ou em uma pool de mineração. O que tem um preço acessível para a Eugênia acaba se tornando muito caro para o hacker, especialmente se a recompensa potencial pela fraude não é alta o suficiente para cobrir o custo da geração do endereço personalizado.((("", startref="Avanity04")))((("", startref="vanity04")))((("", startref="eugeniafour")))

[[paper_wallets]]
==== Carteiras de Papel

((("keys and addresses", "advanced forms", "paper wallets")))((("paper wallets", id="paperw04")))((("wallets", "types of", "paper wallets", id="Wpaper04")))Paper wallets are bitcoin private keys printed on paper. Often the paper wallet also includes the corresponding Bitcoin address for convenience, but this is not necessary because it can be derived from the private key.

[WARNING]
====
As carteiras de papel são uma tecnologia OBSOLETA e, portanto, são consideradas perigosas para a maioria dos usuários. Existem muitas armadilhas sutis que podem ser exploradas durante o processo de geração das carteiras, incluindo a possibilidade de que o código gerador seja comprometido por um "_back door_". Centenas de bitcoins já foram roubados dessa forma. As carteiras de papel são mostradas nesta seção apenas para fins informativos e não devem ser usadas para armazenar bitcoins. Use uma frase mnemônica do padrão BIP-39 para fazer backup de suas chaves. Use uma carteira de hardware para armazenar chaves e assinar transações. NÃO USE CARTEIRAS DE PAPEL.
====

As carteiras de papel possuem muitos formatos, tamanhos e designs, mas basicamente elas são apenas uma chave privada e um endereço impressos em um papel. A <<table_4-14>> mostra a forma mais simples de uma carteira de papel.

[[table_4-14]]
.Simplest form of a paper wallet—a printout of the Bitcoin address and private key
[options="header"]
|=======================
|Endereço público|Chave privada (WIF)
|1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x|5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
|=======================

As carteiras de papel possuem muitos designs e tamanhos, com muitos recursos diferentes. A <paper_wallet_simple> mostra um exemplo de uma carteira de papel.

[[paper_wallet_simple]]
.Um exemplo de uma carteira de papel simples
image::images/mbc2_0408.png[]


Algumas são feitas para serem dadas de presente e tem temas sazonais, como as de Natal e Ano Novo. Outras são projetadas para serem armazenadas em um cofre de banco com a chave privada escondida de alguma maneira, seja através de adesivos opacos com raspadinhas, ou dobradas e seladas com um lacre de fita adesiva inviolável.

Outros designs apresentam cópias adicionais das chaves e dos endereços, na forma de canhotos destacáveis semelhantes a canhotos de ingressos, permitindo que você armazene múltiplas cópias para protegê-las de incêndios, enchentes e outros desastres naturais.((("", startref="KAadvanced04")))((("", startref="Wpaper04")))((("", startref="paperw04")))

[[paper_wallet_spw]]
.Um exemplo de uma carteira de papel com um canhoto de backup contendo cópias adicionais das chaves
image::images/mbc2_0412.png[]