[[ch06]]
[[transactions]]
== Transações

[[ch06_intro]]
=== Introdução

((("transactions", "defined")))((("warnings and cautions", see="also security")))Transactions are the most important part of the Bitcoin system. Everything else in bitcoin is designed to ensure that transactions can be created, propagated on the network, validated, and finally added to the global ledger of transactions (the blockchain). Transactions are data structures that encode the transfer of value between participants in the Bitcoin system. Each transaction is a public entry in bitcoin's blockchain, the global double-entry bookkeeping ledger.

Neste capítulo, examinaremos as várias formas de transações, o que elas contêm, como criá-las, como elas são verificadas e como elas se tornam parte do registro permanente de todas as transações. Quando usamos o termo "carteira" neste capítulo, estamos nos referindo ao software que constrói transações, e não apenas ao banco de dados de chaves.

[[tx_structure]]
=== Transações em Detalhe

((("casos de uso", "comprando café", id="alicesix")))No <<ch02_bitcoin_overview>>, analisamos a transação que a Alice usou para pagar pelo café na cafeteria do Bob usando um explorador de blocos (<<alices_transactions_to_bobs_cafe>>).

O explorador de blocos mostra uma transação do "endereço" da Alice para o "endereço" do Bob. Esta é uma visão muito simplificada do que está contido em uma transação. Na verdade, como veremos neste capítulo, muitas das informações mostradas são construídas pelo explorador de blocos e não estão realmente na transação.

[[alices_transactions_to_bobs_cafe]]
.Transação da Alice para a Cafeteria do Bob
image::images/mbc2_0208.png["Alice Coffee Transaction"]

[[transactions_behind_the_scenes]]
==== Transações&#x2014;Nos Bastidores

((("transactions", "behind the scenes details of")))Behind the scenes, an actual transaction looks very different from a transaction provided by a typical block explorer. In fact, most of the high-level constructs we see in the various bitcoin application user interfaces _do not actually exist_ in the Bitcoin system.

Podemos usar a interface de linha de comando do Bitcoin Core (+getrawtransaction+ e +decoderawtransaction+) para recuperar a transação "bruta" da Alice, decodificá-la e ver o que ela contém. O resultado é o seguinte:

[[alice_tx]]
.Transação da Alice decodificada
[source,json]
----
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}
----

Você pode notar algumas coisas sobre esta transação, principalmente as coisas que estão faltando! Onde está o endereço da Alice? Onde está o endereço do Bob? Onde está a entrada de 0.1 "enviada" pela Alice? No bitcoin não há moedas, nem remetentes, nem destinatários, nem saldos, nem contas, nem endereços. Todas essas coisas são construídas em um nível superior para o benefício do usuário, para tornar as coisas mais fáceis de serem entendidas.

Você também pode notar muitos campos estranhos e indecifráveis, assim como _strings_ hexadecimais. Não se preocupe, explicaremos cada campo mostrado aqui em detalhes neste capítulo.

[[tx_inputs_outputs]]
=== Saídas e Entradas de Transação

((("transações", "saídas e entradas", id="Tout06")))((("saídas e entradas", "definição de saídas")))((("saídas de transação não gastas (UTXOs)")))((("conjuntos UTXO")))((("transações", "saídas e entradas", "características da saída")))((("saídas e entradas", "características da saída")))O que dá origem a uma transação de bitcoin é uma _saída de transação_. As saídas de transação (em inglês, _transaction outputs_) são partes indivisíveis da moeda bitcoin, registradas na blockchain e reconhecidas como válidas por toda a rede. Os nós completos do bitcoin rastreiam todas as saídas que estão disponíveis e podem ser gastas, conhecidas como _saídas de transação não gastas_ (em inglês,  _unspent transaction outputs_ ou UTXOs). A coleção de todas as UTXOs é conhecida como o _conjunto UTXO_ e atualmente está na casa das milhões de UTXOs. O conjunto UTXO cresce quando uma nova UTXO é criada e diminui quando uma UTXO é consumida. Cada transação representa uma mudança (transição de estado) no conjunto UTXO.

((("saldos")))Quando dizemos que a carteira de um usuário "recebeu" bitcoin, o que queremos dizer é que a carteira detectou na blockchain um UTXO que pode ser gasto com uma das chaves controladas por essa carteira. Assim, o "saldo" de bitcoin de um usuário é a soma de todo o UTXO que a carteira do usuário pode gastar e que pode estar espalhado entre centenas de transações e em centenas de blocos. O conceito de saldo é criado pela aplicação da carteira. A carteira calcula o saldo do usuário escaneando a blockchain e agregando o valor de qualquer UTXO que a carteira possa gastar com as chaves que ela controla. A maioria das carteiras mantém um banco de dados ou usa um serviço de banco de dados para armazenar um conjunto de referência rápida de todo o UTXO que podem gastar com as chaves que controlam.

((("saídas de transações gastas (STXO)")))<<utxo-stxo>>exibe a blockchain em três momentos diferentes, conforme a cadeia de transações entre Joe e Gopesh que está sendo construída. Observe como cada transação gasta um UTXO que foi criado em uma transação anterior, transformando-o em uma _saída de transação gasta_ ou _STXO_. Como a transação nº 1 (de Joe para Alice) gasta um único UTXO (de Joe) e cria um único UTXO (para Alice), ela não modifica o tamanho do conjunto do UTXO. Por outro lado, as transações 2 e 3 criam saídas de troco para o remetente, gastando um único UTXO e criando dois UTXO (o pagamento e a saída de troco). Portanto, cada um deles aumenta o tamanho do conjunto UTXO em 1.

[[utxo-stxo]]
.Cadeia de transações entre Joe e Gopesh sendo construída na blockchain
image::images/mbc2_0609.png["Cadeia de transação entre Joe e Gopesh sendo construída na blockchain"]

((("satoshis")))A saída de uma transação pode ter um valor arbitrário (inteiro) denominado como um múltiplo de satoshis. Assim como os dólares podem ser divididos em até duas casas decimais como centavos, o bitcoin pode ser dividido em até oito casas decimais como satoshis. Embora uma saída possa ter qualquer valor arbitrário, uma vez criada, ela é indivisível. Esta é uma característica importante das saídas que precisa ser enfatizada: as saídas são unidades de valor _discretas_ e _indivisíveis_, denominadas em satoshis inteiros. Uma saída não gasta só pode ser consumida em sua totalidade por uma transação.

((("troco, criando")))Se uma UTXO é maior do que o valor desejado de uma transação, ela precisa ser totalmente consumida e um troco deve ser gerado na transação. Em outras palavras, se você possui uma UTXO que vale 20 bitcoins, e você quer pagar apenas 1 bitcoin, a sua transação precisa consumir toda a UTXO de 20 bitcoins e produzir duas saídas: uma que paga 1 bitcoin para o destinatário desejado e outra que paga 19 bitcoins em troco de volta para a sua carteira. Devido à natureza indivisível das saídas de transação, a maioria das transações de bitcoin precisa gerar troco.

Imagine uma cliente comprando uma bebida de $1,50, pegando sua carteira e tentando achar uma combinação de moedas e notas para atingir o valor de $1,50. A cliente poderá escolher pagar a quantia exata, se disponível, com uma nota de um dólar e duas moedas de 25 centavos, ou com uma combinação de pequenas denominações (6 moedas de 25 centavos), ou, se necessário, com uma unidade maior, como uma nota de 5 dólares. Se ela der dinheiro em excesso ao dono da loja, digamos $5, ela esperará um troco de $3,50, o qual ela guardará em sua carteira, onde ficará disponível para transações futuras.

De maneira semelhante, uma transação de bitcoin precisa ser criada a partir de uma UTXO do usuário em quaisquer denominações que o usuário tiver disponível. Os usuários não podem dividir uma UTXO pela metade, da mesma maneira que eles não podem cortar uma nota de um dólar pela metade e usá-la para fazer pagamentos. O aplicativo de carteira do usuário geralmente selecionará algumas UTXOs entre as UTXOs disponíveis do usuário, com o objetivo de juntar uma quantia maior ou igual ao valor desejado da transação.

Assim como na vida real, a aplicação de bitcoin possui várias estratégias para satisfazer a quantia de compra: combinar várias unidades menores, procurar pelo troco exato ou usar uma unidade única maior que o valor da transação e receber o troco. Toda essa complexa administração das UTXOs gastáveis é feita de maneira automática pela carteira do usuário, e os usuários sequer tomam conhecimento dela. A administração das UTXOs só é relevante se você for um programador e estiver construindo transações brutas a partir de UTXOs.

Uma transação consome saídas de transação não gastas registradas anteriormente e cria novas saídas de transação que podem ser consumidas por uma transação futura. Dessa forma, pedaços de valor de bitcoin passam de proprietário a proprietário em uma cadeia de transações que consome e cria UTXOs.

((("transações", "transações coinbase")))((("transações coinbase")))((("mineração e consenso", "transações coinbase")))A exceção para a cadeia de entradas e saídas é um tipo especial de transação chamada de transação _coinbase_, que é a primeira transação em cada bloco. Essa transação é inserida no bloco pelo minerador "vencedor" e cria bitcoins novos, recém-criados, que serão pagos para o minerador como uma recompensa por ter conseguido minerar o bloco. Esta transação especial não consome UTXOs; em vez disso, ela tem um tipo especial de entrada chamada "coinbase". É assim que a oferta monetária do bitcoin é criada durante o processo de mineração, como veremos no <<mining>>.

[TIP]
====
E o que vem primeiro? As entradas ou as saídas, a galinha ou o ovo? Falando estritamente, as saídas vem primeiro, pois as transações coinbase, que geram os novos bitcoins, não tem entradas e criam saídas a partir do nada.
====

[[tx_outs]]
==== Saídas de Transação

((("transações", "saídas e entradas", "componentes da saída")))((("saídas e entradas", "partes da saída")))Toda transação de bitcoin cria saídas (em inglês, _outputs_), que são gravadas no livro-razão do bitcoin (a cadeia de blocos). Quase todas essas saídas, com uma exceção (ver <<op_return>>), criam partes de bitcoin gastáveis chamadas _saídas de transação não gastas_ ou UTXO (em inglês, _Unspent Transaction Output_), que são então reconhecidas por toda a rede e se tornam disponíveis para que o dono gaste em uma transação futura.

UTXO are tracked by every full-node Bitcoin client in the UTXO set. New transactions consume (spend) one or more of these outputs from the UTXO set.

As saídas de transação consistem em duas partes:

* Uma quantidade de bitcoin, denominada em _satoshis_, a menor unidade do bitcoin
* Um quebra-cabeça criptográfico que determina as condições necessárias para se gastar a saída

((("scripts de travamento")))((("scripts", "scripts de travamento")))((("testemunhas")))((("scriptPubKey")))O quebra-cabeça criptográfico também é conhecido como um _script de travamento_ (em inglês, _locking script_), um _script de testemunha_ (em inglês, _witness script_) ou um +scriptPubKey+.

A linguagem de script da transação, usada no script de travamento mencionado anteriormente, é discutida em detalhes em <<tx_script>>.

Agora, vamos dar uma olhada na transação da Alice (mostrada anteriormente em <<transactions_behind_the_scenes>>) e ver se conseguimos identificar as saídas. Na codificação JSON, as saídas estão em um array (uma lista) chamado +vout+:

[source,json]
----
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
    OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]
----

Como você pode ver, a transação contém duas saídas. Cada saída é definida por um valor e um quebra-cabeça criptográfico. Na codificação mostrada pelo Bitcoin Core, o valor (em inglês, +value+) é mostrado em bitcoin, mas na transação em si ele é registrado como um número inteiro denominado em satoshis. A segunda parte de cada saída é o quebra-cabeça criptográfico que define as condições de gasto. O Bitcoin Core exibe-o como +scriptPubKey+ e nos mostra uma representação legível do script.

O tópico sobre o travamento e o destravamento de UTXOs será discutido mais tarde, em <<tx_lock_unlock>>. A linguagem de script que é usada para o script em +scriptPubKey+ é discutida em <<tx_script>>. Mas antes de nos aprofundarmos nesses tópicos, precisamos entender a estrutura geral das entradas e saídas de transação.

===== Serialização da Transação&#x2014;saídas

((("transações", "saídas e entradas", "estrutura das")))((("saídas e entradas", "estrutura das")))((("serialização", "saídas")))Quando as transações são transmitidas pela rede ou trocadas entre aplicativos, elas são _serializadas_. Serialização é o processo de converter a representação interna de uma estrutura de dados em um formato que pode ser transmitido um byte por vez, também conhecido como um fluxo de bytes. A serialização é mais comumente usada para codificar estruturas de dados para transmissão em uma rede ou para armazenamento em um arquivo. O formato de serialização de uma saída de transação é mostrado na <<tx_out_structure>>.

[[tx_out_structure]]
.Serialização da saída de transação
[options="header"]
|=======
|Tamanho| Campo | Descrição
| 8 bytes (little-endian) | Quantia  | Valor de bitcoin em satoshis (10^-8^ bitcoin)
| 1&#x2013;9 bytes (VarInt) | Tamanho do Script de Travamento | Comprimento em bytes do Script de Travamento
| Variável | Script de Travamento | Um script definindo as condições necessárias para se gastar a saída
|=======

A maioria das bibliotecas e frameworks de bitcoin não armazena transações internamente como fluxos de bytes, pois isso exigiria uma análise sintática complexa toda vez que você precisasse acessar um único campo. Por conveniência e legibilidade, as bibliotecas de bitcoin armazenam as transações internamente em estruturas de dados (geralmente estruturas orientadas a objetos).

((("deserialização")))((("análise sintática")))((("transações", "análise sintática")))O processo de conversão da representação em fluxo de bytes de uma transação em uma estrutura de dados da representação interna de uma biblioteca é chamada de _deserialização_ ou _análise sintática da transação_ (em inglês, _transaction parsing_). O processo de conversão de volta para um fluxo de bytes, a fim de ser transmitido pela rede, submetido a uma função de hash ou armazenado em disco, é chamado de _serialização_. A maioria das bibliotecas do bitcoin possui funções para fazer a serialização e a desserialização de transações.

Veja se você consegue decodificar manualmente a transação da Alice a partir da forma hexadecimal serializada, encontrando alguns dos elementos que vimos anteriormente. Para ajudá-lo, a seção que contém as duas saídas está destacada no <<example_6_1>>:

[[example_6_1]]
.Transação da Alice, serializada e apresentada em notação hexadecimal
====
+0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+
+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+
+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+
+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+
+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+
+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+
+7b4a10fa336a8d752adfffffffff02+*+60e31600000000001976a914ab6+*
*+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+*
*+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac+*
+00000000+
====

Aqui estão algumas dicas:

* Existem duas saídas na seção destacada, cada uma serializada conforme mostrado na <<tx_out_structure>>.
* O valor de 0,015 bitcoin equivale a 1.500.000 satoshis, que é +16 e3 60+ em hexadecimal.
* Na transação serializada, o valor +16 e3 60+ é codificado na ordem de bytes _little-endian_ (byte menos significativo primeiro), resultando em +60 e3 16+.
* O comprimento do +scriptPubKey+ é 25 bytes, que é +19+ em hexadecimal.

[[tx_inputs]]
==== Entradas de Transação

((("transações", "saídas e entradas", "componentes da entrada")))((("saídas e entradas", "componentes da entrada")))((("saídas de transação não gastas (UTXO)")))((("conjuntos UTXO")))As entradas de transação identificam (por referência) qual UTXO será consumida e fornecem uma prova de posse através de um script de destravamento.

Para construir uma transação, uma carteira seleciona, das UTXOs que ela controla, UTXOs com valor suficiente para fazer o pagamento solicitado. Às vezes, uma UTXO é suficiente, outras vezes, mais de uma é necessária. Para cada UTXO que será consumida para fazer este pagamento, a carteira cria uma entrada apontando para a UTXO e a destrava com um script de destravamento.

Vamos analisar os componentes de uma entrada em maiores detalhes. A primeira parte de uma entrada é um apontador para uma UTXO por referência ao hash da transação e um índice de saída, que identifica a UTXO específica naquela transação. A segunda parte é um script de destravamento, que a carteira constrói para atender às condições de gasto definidas na UTXO. Na maioria das vezes, o script de destravamento é uma assinatura digital e uma chave pública que provam a posse do bitcoin. No entanto, nem todos os scripts de destravamento contêm assinaturas. A terceira parte é um número de sequência, que será discutido posteriormente.

Considere nosso exemplo em <<transactions_behind_the_scenes>>. As entradas da transação são um array (lista) chamado +vin+:

[[vin]]
.As entradas de transação na transação da Alice
[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]
----

Como você pode ver, só existe uma entrada na lista (porque uma UTXO continha valor suficiente para fazer este pagamento). A entrada contém quatro elementos:

* Um ((("IDs de transação (txid)")))ID de transação, referenciando a transação que contém a UTXO sendo gasta
* Um índice de saída (+vout+), identificando qual UTXO daquela transação é referenciada (a primeira tem índice igual a zero)
* Um +scriptSig+, que satisfaz as condições colocadas na UTXO, destravando-a para ser gasta
* Um número de sequência (que será discutido mais tarde)

Na transação da Alice, a entrada aponta para o ID de transação:

----
7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18
----

e o índice de saída +0+ (ou seja, a primeira UTXO criada por aquela transação). O script de destravamento é construído pela carteira de Alice primeiro recuperando a UTXO referenciada, depois examinando seu script de travamento e, em seguida, usando-o para construir o script de destravamento necessário para satisfazê-lo.

Olhando apenas para a entrada, você deve ter notado que não sabemos nada sobre esta UTXO, exceto uma referência à transação pai que a contém. Não sabemos seu valor (quantia em satoshis) e não conhecemos o script de travamento que define as condições para gastá-la. Para encontrar essas informações, devemos recuperar a UTXO referenciada recuperando a transação pai que a contém. Observe que, como o valor da entrada não é declarado explicitamente, também devemos usar a UTXO referenciada para calcular as taxas que serão pagas nesta transação (ver <<tx_fees>>).

Não é apenas a carteira da Alice que precisa recuperar as UTXOs referenciadas nas entradas. Uma vez que essa transação é transmitida para a rede, todos os nós validadores também precisarão recuperar as UTXOs referenciadas nas entradas da transação para poder validar a transação.

As transações por si sós parecem incompletas, pois elas não têm contexto. Elas fazem referência às UTXOs em suas entradas, mas, sem recuperar essas UTXOs, não podemos saber o valor das entradas ou suas condições de travamento. Ao escrever um software de bitcoin, sempre que você decodificar uma transação com a intenção de validá-la, ou para contar as taxas, ou para verificar o script de destravamento, seu código terá primeiro de recuperar a UTXO referenciada da blockchain para construir o contexto que está implícito, mas que não está presente nas referências de UTXO das entradas. Por exemplo, para calcular o valor pago em taxas, é necessário saber a soma dos valores das entradas e saídas. Mas sem recuperar as UTXOs referenciadas nas entradas, você não sabe o valor delas. Portanto, uma operação aparentemente simples, como calcular as taxas de uma única transação, na verdade envolve várias etapas e dados de múltiplas transações.

Podemos usar a mesma sequência de comandos do Bitcoin Core que usamos ao recuperar a transação da Alice (+getrawtransaction+ e +decoderawtransaction+). Com isso, conseguimos obter a UTXO referenciada na entrada da transação da Alice e dar uma olhada:

[[alice_input_tx]]
.A UTXO da transação anterior, referenciada na entrada da transação da Alice
[source,json]
----
"vout": [
   {
     "value": 0.10000000,
     "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
   }
 ]
----

Vemos que esta UTXO tem um valor de 0,1 BTC e que ela possui um script de travamento (+scriptPubKey+) que contém "OP_DUP OP_HASH160...".

[TIP]
====
Para entender completamente a transação da Alice, tivemos que recuperar a transação anterior referenciada como entrada. Uma função que recupera transações anteriores e saídas de transação não gastas é muito comum e existe em quase todas as bibliotecas e APIs do bitcoin.
====

===== Serialização da Transação&#x2014;entradas

((("serialização", "entradas")))((("transações", "saídas e entradas", "serialização da entrada")))((("saídas e entradas", "serialização da entrada")))Quando as transações são serializadas para transmissão na rede, suas entradas são codificadas em um fluxo de bytes, conforme mostrado na <<tx_in_structure>>.

[[tx_in_structure]]
.Serialização da entrada de transação
[options="header"]
|=======
|Tamanho| Campo | Descrição
| 32 bytes | Hash da Transação | Apontador para a transação contendo a UTXO a ser gasta
| 4 bytes | Índice da Saída | O número índice da UTXO a ser gasta; o primeiro é 0
| 1&#x2013;9 bytes (VarInt) | Tamanho do Script de Destravamento | Comprimento em bytes do Script de Destravamento
| Variável | Script de Destravamento | Um script que preenche as condições necessárias para o script de travamento da UTXO
| 4 bytes | Número de Sequência | Usado para o locktime ou desabilitado (0xFFFFFFFF)
|=======

Assim como fizemos com as saídas, vamos ver se conseguimos encontrar as entradas da transação da Alice no formato serializado. Primeiro, as entradas decodificadas:

[source,json]
----
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
],
----

Agora, vamos ver se conseguimos identificar esses campos na codificação hexadecimal serializada no <<example_6_2>>:

[[example_6_2]]
.Transação da Alice, serializada e apresentada em notação hexadecimal
====
+0100000001+*+186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd73+*
*+4d2804fe65fa35779000000008b483045022100884d142d86652a3f47+*
*+ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039+*
*+ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813+*
*+01410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade84+*
*+16ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc1+*
*+7b4a10fa336a8d752adfffffffff+*+0260e31600000000001976a914ab6+
+8025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef800000000000+
+1976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000+
+000+
====

Dicas:

* O ID de transação é serializado em ordem de byte reversa, então começa com (hex) +18+ e termina com +79+
* O índice da saída é um grupo de zeros de 4 bytes, que é fácil de identificar
* O comprimento do +scriptSig+ é 139 bytes, ou +8b+ em hexadecimal
* O número de sequência é definido como +FFFFFFFF+, também fácil de ser identificado((("", startref="alicesix")))

O ScriptSig é um tipo específico de script de destravamento que, quando serializado para transmissão na rede, as entradas são codificadas em um fluxo de bytes, conforme mostrado na <<scriptsig_in_structure>>. A serialização do campo de assinatura é detalhada em <<seralization_of_signatures_der>>. O campo de assinatura também inclui um tipo de hash de assinatura (SIGHASH), que é detalhado em <<sighash_types>>.

[[scriptsig_in_structure]]
.Serialização de entrada ScriptSig
[options="header"]
|=======
|Tamanho| Campo | Descrição
| 1&#x2013;9 bytes (VarInt) | Tamanho da Assinatura | Comprimento da assinatura em bytes
| Variável | Assinatura | Uma assinatura que é produzida pela carteira do usuário a partir de sua chave privada, que inclui um SIGHASH
| 1&#x2013;9 bytes (VarInt) | Tamanho da Chave Pública | Comprimento da chave pública em bytes
| Variável | Chave Pública | A chave pública, não transformada em hash
|=======

[[tx_fees]]
==== Taxas de Transação

((("transações", "saídas e entradas", "taxas de transação")))((("taxas", "taxas de transação")))((("mineração e consenso", "recompensas e taxas")))A maioria das transações inclui taxas de transação, que compensam os mineradores de bitcoin por protegerem a rede. As taxas por si sós também servem como um mecanismo de segurança, tornando economicamente inviável para que atacantes inundem a rede com transações. A mineração, as taxas e as recompensas coletadas pelos mineradores são discutidas em maiores detalhes no <<mining>>.

Esta seção examina como as taxas de transação são incluídas em uma transação típica. A maioria das carteiras calcula e inclui automaticamente as taxas de transação. No entanto, se você estiver criando transações através de programação ou usando uma interface de linha de comando, você deve contabilizar e incluir manualmente essas taxas.

As taxas de transação servem como um incentivo para incluir (minerar) uma transação no próximo bloco e também como um desincentivo ao abuso do sistema, ao imporem um pequeno custo em cada transação. As taxas de transação são coletadas pelo minerador que minera o bloco que registra a transação na blockchain.

Transaction fees are calculated based on the size of the transaction in kilobytes, not the value of the transaction in bitcoin. Overall, transaction fees are set based on market forces within the Bitcoin network. Miners prioritize transactions based on many different criteria, including fees, and might even process transactions for free under certain circumstances. Transaction fees affect the processing priority, meaning that a transaction with sufficient fees is likely to be included in the next block mined, whereas a transaction with insufficient or no fees might be delayed, processed on a best-effort basis after a few blocks, or not processed at all. Transaction fees are not mandatory, and transactions without fees might be processed eventually; however, including transaction fees encourages priority processing.

Ao longo do tempo, a forma como as taxas são calculadas e o efeito que elas tem na prioridade das transações evoluiu. Inicialmente, as taxas de transação eram fixas e constantes em toda a rede. Gradualmente, a estrutura de taxas foi flexibilizada, e agora as taxas podem ser influenciadas por forças do mercado, com base na capacidade da rede e no volume de transações. Desde, pelo menos, o início de 2016, os limites de capacidade no bitcoin criaram concorrência entre as transações, resultando em taxas mais altas e efetivamente tornando as transações gratuitas uma coisa do passado. Transações com taxa zero ou com taxa muito baixa raramente são mineradas e, às vezes, nem mesmo são propagadas pela rede.

((("taxas", "políticas de taxa para retransmissão")))((("opção minrelaytxfee")))No Bitcoin Core, as políticas de taxa para retransmissão são definidas pela opção +minrelaytxfee+. O valor padrão atual da +minrelaytxfee+ é 0,00001 bitcoin ou um centésimo de milibitcoin por kilobyte. Portanto, por padrão, as transações com uma taxa inferior a 0,00001 bitcoin são tratadas como gratuitas e só serão retransmitidas se houver espaço na mempool; caso contrário, elas serão descartadas. Os nós de bitcoin podem substituir a política de taxa para retransmissão padrão ajustando o valor da +minrelaytxfee+.

((("taxas dinâmicas")))((("taxas", "taxas dinâmicas")))Qualquer serviço de bitcoin que cria transações, incluindo carteiras, corretoras, aplicativos de varejo, etc., _deve_ implementar taxas dinâmicas. As taxas dinâmicas podem ser implementadas por meio de um serviço de estimativa de taxa de terceiros ou com um algoritmo de estimativa de taxa integrado. Se você não tiver certeza, comece com um serviço de terceiros e, à medida que ganhar experiência, projete e implemente seu próprio algoritmo, caso você não queira mais ficar dependente de terceiros.

Os algoritmos de estimativa de taxa calculam a taxa apropriada, com base na capacidade e nas taxas oferecidas pelas transações que estão "competindo". Esses algoritmos variam dos mais simples (taxa média ou mediana no último bloco) aos mais sofisticados (análise estatística). Eles estimam a taxa necessária (em satoshis por byte) que dará a uma transação uma alta probabilidade de ser selecionada e incluída em um determinado número de blocos. A maioria dos serviços oferece aos usuários a opção de escolher taxas de prioridade alta, média ou baixa. Alta prioridade significa que os usuários pagam taxas mais altas, mas a transação provavelmente será incluída no próximo bloco. Prioridades média e baixa significam que os usuários pagam taxas de transação mais baixas, mas a confirmação das transações pode demorar muito mais.

((("bitcoinfees (serviço de terceiros)")))Muitos aplicativos de carteira usam serviços de terceiros para cálculos de taxas. Um serviço popular é o https://bitcoinfees.earn.com/[_https://bitcoinfees.earn.com/_], que fornece uma API e um gráfico mostrando a taxa em satoshis/byte para diferentes prioridades.

[TIP]
====
((("static fees")))((("fees", "static fees")))Static fees are no longer viable on the Bitcoin network. Wallets that set static fees will produce a poor user experience as transactions will often get "stuck" and remain unconfirmed. Users who don't understand bitcoin transactions and fees are dismayed by "stuck" transactions because they think they've lost their money.
====

O gráfico na <<bitcoinfeesearncom>> mostra a estimativa em tempo real das taxas em incrementos de 10 satoshis/byte e o tempo de confirmação esperado (em minutos e número de blocos) para transações com taxas em cada faixa. Para cada faixa de taxa (por exemplo, 61&#x2013;70 satoshis/byte), duas barras horizontais mostram o número de transações não confirmadas (1.405) e o número total de transações com taxas nessa faixa nas últimas 24 horas (102.975). Com base no gráfico, a taxa de alta prioridade recomendada naquele momento era de 80 satoshis/byte, uma taxa que provavelmente faria com que a transação fosse minerada no bloco seguinte (com atraso de bloco zero). Para se ter uma idéia, o tamanho mediano de uma transação é de 226 bytes, então a taxa recomendada para esse tamanho de transação seria 18.080 satoshis (0,00018080 BTC).

Os dados de estimativa de taxa podem ser recuperados por meio de uma API HTTP REST simples, em https://bitcoinfees.earn.com/api/v1/fees/recommended[https://bitcoinfees.earn.com/api/v1/fees/recommended]. Por exemplo, usando-se o comando +curl+ na linha de comando:

.Usando a API de estimativa de taxa
----
$ curl https://bitcoinfees.earn.com/api/v1/fees/recommended

{"fastestFee":80,"halfHourFee":80,"hourFee":60}
----

A API retorna um objeto JSON com a estimativa de taxa atual para a confirmação mais rápida (+fastFee+), para uma confirmação dentro de três blocos (+halfHourFee+) e para uma confirmação dentro de seis blocos (+hourFee+), em satoshis por byte.

[[bitcoinfeesearncom]]
.Serviço de estimativa de taxa bitcoinfees.earn.com
image::images/mbc2_0602.png[Fee Estimation Service bitcoinfees.earn.com]

==== Adicionando Taxas às Transações

A estrutura de dados das transações não tem um campo para as taxas. Em vez disso, infere-se que as taxas são a diferença entre a soma das entradas e a soma das saídas. Qualquer valor em excesso que permanece após todas as saídas terem sido deduzidas de todas as entradas é a taxa que é coletada pelos mineradores.

[[tx_fee_equation]]
.As taxas de transação são implicitamente consideradas como o resto da subtração das entradas pela saídas:
----
Taxas = Soma(Entradas) – Soma(Saídas)
----

Isso é um elemento relativamente confuso das transações, e é um ponto importante para se compreender, pois se você está construindo as suas próprias transações, você deve se certificar de que você não incluiu uma taxa muito grande ao subutilizar as entradas. Isso significa que você deve contabilizar todas as entradas, e, se necessário, criar troco, caso contrário, você acabará dando uma gorjeta grande demais para os mineradores!

Por exemplo, se você consumir uma UTXO de 20 bitcoins para fazer um pagamento de 1 bitcoin, você precisa incluir uma saída de troco de 19 bitcoins de volta para a sua carteira. Caso contrário, os 19 bitcoins que sobrarem serão contados como uma taxa de transação e serão coletados pelo minerador que minerar a sua transação em um bloco. A sua transação vai receber alta prioridade e o minerador vai ficar muito feliz, mas provavelmente não era isso que você queria fazer.

[WARNING]
====
((("advertências e cuidados", "saídas de troco")))Se você se esquecer de adicionar uma saída de troco em uma transação construída manualmente, o seu troco será usado para pagar a taxa da transação. Provavelmente a sua real intenção não era dizer ao minerador "Pode ficar com troco!"
====

((("casos de uso", "comprando café")))Vamos ver como isso funciona na prática, ao analisar novamente a compra da xícara de café da Alice. A Alice quer gastar 0,015 BTC para pagar pelo café. Para ter a certeza de que essa transação será processada prontamente, ela terá que incluir uma taxa de transação, que digamos que seja de 0,0005 BTC. Isso significa que o custo total da transação será de 0,0155 BTC. A carteira dela, portanto, precisará usar um conjunto de UTXOs cuja soma resulte em 0,0155 BTC ou mais e, se necessário, terá que criar o troco. Digamos que a carteira dela tem uma UTXO de 0,1 BTC disponível. Portanto ela precisará consumir essa UTXO, criando uma saída de 0,015 BTC para a Cafeteria do Bob e uma segunda saída de 0,0845 BTC de troco de volta para a própria carteira dela, deixando 0,0005 BTC não alocado, que é uma taxa implícita pela transação.

((("use cases", "charitable donations")))((("charitable donations")))Agora vamos ver um cenário diferente. A Eugênia, nossa diretora da instituição de caridade para crianças nas Filipinas, completou uma campanha para arrecadação de fundos para comprar livros escolares para as crianças. Ela recebeu milhares de pequenas doações de pessoas de todos os lugares do mundo, totalizando 50 bitcoins, então sua carteira está cheia de pagamentos muito pequenos (UTXOs). Agora ela que comprar centenas de livros escolares da editora local, pagando em bitcoin.

Ao tentar construir uma única transação de pagamento com uma quantia maior, o aplicativo de carteira da Eugênia deve utilizar o conjunto UTXO disponível, que é composto por várias quantias menores. Isso significa que a transação resultante utilizará mais de uma centena de UTXOs de pequeno valor como entradas, e terá apenas uma única saída, que será o pagamento à editora do livro. Uma transação com tantas entradas terá mais do que um kilobyte, talvez vários kilobytes. Como resultado, ela exigirá uma taxa muito maior do que a transação de tamanho mediano.

O aplicativo de carteira da Eugênia calculará a taxa apropriada ao medir o tamanho da transação e multiplicá-lo pela taxa por kilobyte. Muitas carteiras pagarão taxas extras para transações de maior tamanho, a fim de garantir que a transação seja processada prontamente. A taxa não é maior pelo fato de a Eugênia estar gastando mais dinheiro, mas pelo fato de a transação dela ser mais complexa e ter um tamanho maior—a taxa é independente do valor da transação em bitcoins.((("", startref="Tout06")))

[[tx_script]]
[role="pagebreak-before less_space_h1"]
=== Scripts de Transação e Linguagem de Script

((("transações", "scripts e linguagem Script", id="Tsript06")))((("scripting", "transactions and", id="Stransact06")))A linguagem de script da transação do bitcoin, chamada _Script_, é uma linguagem de execução baseada em pilha de notação polonesa reversa, semelhante à linguagem Forth. Se isso soa como um jargão, você provavelmente não estudou as linguagens de programação dos anos 1960, mas tudo bem&#x2014;explicaremos tudo o que você precisa saber neste capítulo. Tanto o script de travamento colocado em uma UTXO quanto o script de destravamento são escritos nesta linguagem de script. Quando uma transação é validada, o script de destravamento em cada entrada é executado junto com o script de travamento correspondente para ver se ele satisfaz a condição de gasto.

A Script é uma linguagem muito simples que foi projetada para ser limitada em escopo e executável em uma variedade de hardwares, talvez tão simples quanto um dispositivo embutido. Ela requer processamento mínimo e não consegue fazer muitas das coisas extravagantes que as linguagens de programação modernas conseguem fazer. Para seu uso na validação de dinheiro programável, este é um recurso de segurança deliberado.

((("Pay-to-Public-Key-Hash (P2PKH)")))Today, most transactions processed through the Bitcoin network have the form "Payment to Bob's Bitcoin address" and are based on a script called a Pay-to-Public-Key-Hash script.  However, bitcoin transactions are not limited to the "Payment to Bob's Bitcoin address" script. In fact, locking scripts can be written to express a vast variety of complex conditions. In order to understand these more complex scripts, we must first understand the basics of transaction scripts and script language.

Nesta seção, demonstraremos os componentes básicos da linguagem de script da transação de bitcoin e mostraremos como ela pode ser usada para expressar condições simples para que o dinheiro seja gasto e como essas condições podem ser satisfeitas através de scripts de destravamento.

[TIP]
====
((("dinheiro programável")))A validação da transação de bitcoin não é baseada em um padrão estático, em vez disso, ela é obtida através da execução de uma linguagem de script. Essa linguagem permite que uma variedade quase infinita de condições seja expressa. É dessa maneira que o bitcoin recebe o poder de ser um "dinheiro programável".
====


==== Incompletude de Turing

((("Turing incompleteness")))The bitcoin transaction script language contains many operators, but is deliberately limited in one important way--there are no loops or complex flow control capabilities other than conditional flow control. This ensures that the language is not _Turing Complete_, meaning that scripts have limited complexity and predictable execution times. Script is not a general-purpose language. ((("denial-of-service attacks")))((("denial-of-service attacks", see="also security")))((("security", "denial-of-service attacks")))These limitations ensure that the language cannot be used to create an infinite loop or other form of "logic bomb" that could be embedded in a transaction in a way that causes a denial-of-service attack against the Bitcoin network. Remember, every transaction is validated by every full node on the Bitcoin network. A limited language prevents the transaction validation mechanism from being used as a vulnerability.

==== Verificação sem Estado

((("stateless verification")))The bitcoin transaction script language is stateless, in that there is no state prior to execution of the script, or state saved after execution of the script. Therefore, all the information needed to execute a script is contained within the script. A script will predictably execute the same way on any system. If your system verifies a script, you can be sure that every other system in the Bitcoin network will also verify the script, meaning that a valid transaction is valid for everyone and everyone knows this. This predictability of outcomes is an essential benefit of the Bitcoin system.

[[tx_lock_unlock]]
==== Construção do Script (Travamento + Destravamento)

O mecanismo de validação de transações do bitcoin conta com dois tipos de scripts para validar transações: um script de travamento e um script de destravamento.

((("locking scripts")))((("unlocking scripts")))((("scripting", "locking scripts")))A locking script is a spending condition placed on an output: it specifies the conditions that must be met to spend the output in the future. ((("scriptPubKey")))Historically, the locking script was called a _scriptPubKey_, because it usually contained a public key or Bitcoin address (public key hash). In this book we refer to it as a "locking script" to acknowledge the much broader range of possibilities of this scripting technology. In most bitcoin applications, what we refer to as a locking script will appear in the source code as +scriptPubKey+. ((("witnesses")))((("cryptographic puzzles")))You will also see the locking script referred to as a _witness script_ (see <<segwit>>) or more generally as a _cryptographic puzzle_. These terms all mean the same thing, at different levels of abstraction.

Um script de destravamento é um script que "resolve", ou satisfaz, as condições que foram colocadas em uma saída por um script de travamento, permitindo que a saída seja gasta. Os scripts de destravamento fazem parte de todas as entradas de transação. Na maioria das vezes, eles contêm uma assinatura digital produzida pela carteira do usuário a partir de sua chave privada. ((("scriptSig")))Historicamente, o script de destravamento era chamado de _scriptSig_, porque ele geralmente continha uma assinatura digital. Na maioria das aplicações de bitcoin, o código-fonte refere-se ao script de destravamento como +scriptSig+. Você também verá o script de destravamento sendo referido como uma _testemunha_ (em inglês, _witness_) (ver <<segwit>>). Neste livro, nos referimos a ele como um "script de destravamento", para reconhecer a gama muito maior de exigências dos scripts de travamento, pois nem todos os scripts de destravamento precisam conter assinaturas.

Cada nó validador do bitcoin validará transações ao executar os scripts de travamento e destravamento juntos. Cada entrada contém um script de destravamento e refere-se a uma UTXO previamente existente. O software de validação copiará o script de destravamento, recuperará a UTXO referenciada pela entrada e copiará o script de travamento dessa UTXO. A seguir, os scripts de destravamento e travamento são executados em sequência. A entrada é considerada válida se o script de destravamento satisfizer as condições do script de travamento (ver <<script_exec>>). Todas as entradas são validadas de forma independente, como parte da validação geral da transação.

Como a UTXO é armazenada permanentemente na blockchain, ela é invariável, não sendo afetada por tentativas fracassadas de gastá-la através de uma referência em uma nova transação. Somente uma transação válida, que satisfaça corretamente as condições da saída, fará com que uma saída seja considerada "gasta" e seja removida do conjunto de saídas de transação não gastas (conjunto UTXO).

A <<scriptSig_and_scriptPubKey>> é um exemplo de scripts de destravamento e travamento para o tipo mais comum de transação de bitcoin (um pagamento para um hash de endereço público), demonstrando o script combinado resultante da concatenação dos scripts de destravamento e travamento antes da validação do script.

[[scriptSig_and_scriptPubKey]]
.Combinando o scriptSig e o scriptPubKey para avaliar um script de transação
image::images/mbc2_0603.png["scriptSig_and_scriptPubKey"]

===== O stack de execução do script

A linguagem de script do bitcoin é considerada uma linguagem baseada em stack, pois ela usa uma estrutura de dados chamada de _stack_ (em português, _pilha_). Um stack é uma estrutura de dados muito simples, que pode ser imaginada como uma pilha de cartas de baralho. Um stack permite duas operações: adicionar ("push") e remover ("pop"). "Adicionar" ("push") adiciona um item no topo da pilha. "Remover" ("pop") retira o item que está no topo da pilha. As operações em uma pilha só podem agir no item que está no topo da pilha. Uma estrutura de dados em pilha também é chamada de Last-In-First-Out (o último a entrar é o primeiro a sair) ou fila "LIFO".

A linguagem de script executa o script ao processar cada item da esquerda para a direita. Os números (constantes de dados) são adicionados no stack. Os operadores adicionam (push) ou removem (pop) um ou mais parâmetros do stack, atuam neles e podem adicionar um resultado no stack. Por exemplo, o operador +OP_ADD+ irá remover dois itens do stack, somá-los e adicionar o resultado da soma no stack.

Os operadores condicionais avaliam uma condição, produzindo um resultado booleano TRUE (VERDADEIRO) ou FALSE (FALSO). Por exemplo, +OP_EQUAL+ remove (pop) dois itens do stack e adiciona TRUE (TRUE representado pelo número 1) se eles forem iguais ou FALSE (representado por zero) se eles não forem iguais. Os scripts de transação do bitcoin geralmente contêm um operador condicional, de maneira que eles possam produzir o resultado TRUE que significa uma transação válida.

===== Um script simples

Agora vamos aplicar o que aprendemos sobre scripts e stacks a alguns exemplos simples.

Na <<simplemath_script>>, o script +2 3 OP_ADD 5 OP_EQUAL+ demonstra o operador de adição aritmética +OP_ADD+ somando dois números e colocando o resultado no stack, seguido pelo operador condicional +OP_EQUAL+, que verifica se a soma resultante é igual a +5+. Para simplificar, o prefixo +OP_+ é omitido no exemplo passo-a-passo. Para obter mais detalhes sobre os operadores de script e as funções disponíveis, consulte o <<tx_script_ops>>.

Although most locking scripts refer to a public key hash (essentially, a Bitcoin address), thereby requiring proof of ownership to spend the funds, the script does not have to be that complex. Any combination of locking and unlocking scripts that results in a TRUE value is valid. The simple arithmetic we used as an example of the scripting language is also a valid locking script that can be used to lock a transaction output.

Use parte do script de exemplo aritmético como sendo o script de travamento:

----
3 OP_ADD 5 OP_EQUAL
----

que pode ser satisfeito através de uma transação contendo uma entrada com o script de destravamento:

----
2
----

O software de validação combina os scripts de travamento e de destravamento e o script resultante é:

----
2 3 OP_ADD 5 OP_EQUAL
----

Conforme vimos no exemplo passo-a-passo da <<simplemath_script>>, quando o script é executado, o resultado é +OP_TRUE+, tornando a transação válida. Não apenas esse é um script de travamento válido, como também a UTXO resultante poderia ser gasta por qualquer pessoa que tivesse as habilidades aritméticas para saber que o número 2 satisfaz o script.

[TIP]
====
((("transações", "válidas e inválidas")))As transações são válidas se o resultado no topo do stack for +TRUE+ (definido como ++&#x7b;0x01&#x7d;++), qualquer valor diferente de zero, não +OP_0+, ou se o stack estiver vazio após a execução do script. As transações são inválidas se o valor do topo do stack for FALSE (um valor vazio de comprimento zero, definido como ++&#x7b;&#x7d;++) ou se a execução do script for suspensa por um operador, como o +OP_VERIFY+, o +OP_RETURN+ ou um terminador condicional como o +OP_ENDIF+. Veja o <<tx_script_ops>> para mais detalhes.
====

[[simplemath_script]]
.Script de validação do bitcoin fazendo uma conta matemática simples
image::images/mbc2_0604.png["TxScriptSimpleMathExample"]

[role="pagebreak-before"]
O script a seguir é um pouco mais complexo, que calcula ++2 + 7 - 3 + 1++. Note que quando o script contém vários operadores em uma linha, o stack permite que os resultados de um operador sejam usados pelo próximo operador:

----
2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL
----

Tente você mesmo validar o script anterior usando papel e caneta. Quando a execução do script terminar, você deve ficar com o valor +TRUE+ no stack.

[[script_exec]]
===== Execução separada de scripts de destravamento e travamento

((("security", "locking and unlocking scripts")))In the original Bitcoin client, the unlocking and locking scripts were concatenated and executed in sequence. For security reasons, this was changed in 2010, because of a vulnerability that allowed a malformed unlocking script to push data onto the stack and corrupt the locking script. In the current implementation, the scripts are executed separately with the stack transferred between the two executions, as described next.

Primeiro, o script de destravamento é executado, usando o mecanismo de execução do stack. Se o script de destravamento for executado sem erros (por exemplo, ele não possui ponteiros "pendentes" faltando), o stack principal é copiado e o script de travamento é executado. Se o resultado da execução do script de travamento com os dados do stack copiados a partir do script de destravamento for "TRUE", o script de destravamento teve sucesso em resolver as condições impostas pelo script de travamento e, portanto, a entrada é uma autorização válida para gastar a UTXO. Se qualquer resultado diferente de "TRUE" permanecer após a execução do script combinado, a entrada é inválida, pois ela não conseguiu satisfazer as condições de gasto impostas na UTXO.


[[p2pkh]]
==== Pay-to-Public-Key-Hash (P2PKH)

((("Pay-to-Public-Key-Hash (P2PKH)")))The vast majority of transactions processed on the Bitcoin network spend outputs locked with a Pay-to-Public-Key-Hash or "P2PKH" script. These outputs contain a locking script that locks the output to a public key hash, more commonly known as a Bitcoin address. An output locked by a P2PKH script can be unlocked (spent) by presenting a public key and a digital signature created by the corresponding private key (see <<digital_sigs>>).

((("use cases", "buying coffee")))For example, let's look at Alice's payment to Bob's Cafe again. Alice made a payment of 0.015 bitcoin to the cafe's Bitcoin address. That transaction output would have a locking script of the form:

----
OP_DUP OP_HASH160 <Hash da Chave Pública do Café> OP_EQUALVERIFY OP_CHECKSIG
----

The +Cafe Public Key Hash+ is equivalent to the Bitcoin address of the cafe, without the Base58Check encoding. Most applications would show the _public key hash_ in hexadecimal encoding and not the familiar Bitcoin address Base58Check format that begins with a "1."

O script de travamento anterior pode ser satisfeito com um script de destravamento com o seguinte formato:

----
<Assinatura do Café> <Chave Pública do Café>
----

Os dois scripts juntos formariam o seguinte script de validação combinado:

----
<Assinatura do Café> <Chave Pública do Café> OP_DUP OP_HASH160
<Hash da Chave Pública do Café> OP_EQUALVERIFY OP_CHECKSIG
----

Quando executado, esse script combinado resultará em TRUE se, e somente se, o script de destravamento preencher as condições definidas pelo script de travamento. Em outras palavras, o resultado será TRUE se o script de destravamento tiver uma assinatura válida da chave privada do café que corresponda ao hash de chave pública que foi definido como uma trava.

As Figuras pass:[<a data-type="xref" href="#P2PubKHash1" data-xrefstyle="select: labelnumber">#P2PubKHash1</a>] e pass:[<a data-type="xref" href="#P2PubKHash2" data-xrefstyle="select: labelnumber">#P2PubKHash2</a>] demonstram (em duas partes) uma execução passo-a-passo do script combinado, que provará que essa é uma transação válida.((("", startref="Tsript06")))((("", startref="Stransact06")))

[[P2PubKHash1]]
.Avaliando um script para uma transação P2PKH (parte 1 de 2)
image::images/mbc2_0605.png["Tx_Script_P2PubKeyHash_1"]

[[P2PubKHash2]]
.Avaliando um script para uma transação P2PKH (parte 2 de 2)
image::images/mbc2_0606.png["Tx_Script_P2PubKeyHash_2"]

[[digital_sigs]]
=== Assinaturas Digitais (ECDSA)

((("transações", "assinaturas digitais e", id="Tdigsig06")))Até agora, não nos aprofundamos em detalhes sobre as "assinaturas digitais". Nesta seção, veremos como as assinaturas digitais funcionam e como elas podem apresentar uma prova de posse de uma chave privada sem revelar essa chave privada.

((("assinaturas digitais", "algoritmo usado")))((("Algoritmo de Assinatura Digital de Curva Elíptica (ECDSA)")))O algoritmo de assinatura digital usado no bitcoin é o _Algoritmo de Assinatura Digital de Curva Elíptica_ (em inglês, _Elliptic Curve Digital Signature Algorithm_ ou _ECDSA_). O ECDSA é o algoritmo usado para assinaturas digitais com base em pares de chaves privadas/públicas em curva elíptica, conforme descrito em <<elliptic_curve>>. O ECDSA é usado pelas funções de script +OP_CHECKSIG+, +OP_CHECKSIGVERIFY+, +OP_CHECKMULTISIG+ e +OP_CHECKMULTISIGVERIFY+. Sempre que você encontrar essas funções em um script de travamento, o script de destravamento necessariamente precisa conter uma assinatura ECDSA.

((("assinaturas digitais", "propósitos das")))Uma assinatura digital tem três finalidades no bitcoin. Primeiro, a assinatura prova que o proprietário da chave privada, que se subentende ser o proprietário dos fundos, _autorizou_ o gasto desses fundos. Em segundo lugar, a prova de autorização é _inegável_ (não repúdio). Em terceiro lugar, a assinatura prova que a transação (ou partes específicas da transação) não foi e _não pode ser modificada_ por ninguém após ter sido assinada.

Observe que cada entrada de transação é assinada de forma independente. Isso é fundamental, pois nem as assinaturas nem as entradas precisam pertencer ou serem usadas pelos mesmos "donos". Um esquema específico de transação chamado "CoinJoin" usa esse fato para criar transações com entradas de diferentes usuários com o objetivo de se obter maior privacidade.

[NOTE]
====
Cada entrada de transação e qualquer assinatura que ela possa conter é _completamente_ independente de qualquer outra entrada ou assinatura. Vários usuários podem se unir para construir transações em que cada um assina apenas uma única entrada.
====

[[digital_signature_definition]]
.Definição de "Assinatura Digital" da Wikipédia
****
((("assinaturas digitais", "definição")))Uma assinatura digital é um esquema matemático usado para demonstrar a autenticidade de uma mensagem ou documentos digitais. Uma assinatura digital válida dá ao destinatário motivos para acreditar que a mensagem foi criada por um remetente conhecido (autenticação), que o remetente não pode negar ter enviado da mensagem (não repúdio) e que a mensagem não foi alterada em trânsito (integridade).

_Fonte: https://en.wikipedia.org/wiki/Digital_signature_
****

==== Como Funcionam as Assinaturas Digitais

((("assinaturas digitais", "como elas funcionam")))Uma assinatura digital é um _esquema matemático_ que consiste em duas partes. A primeira parte é um algoritmo usado para criar uma assinatura, usando uma chave privada (a chave de assinatura), a partir de uma mensagem (a transação). A segunda parte é um algoritmo que permite a qualquer pessoa verificar a assinatura, caso seja fornecida a mensagem e uma chave pública.

===== Criando uma assinatura digital

Na implementação do bitcoin do algoritmo ECDSA, a "mensagem" sendo assinada é a transação, ou, mais precisamente, um hash de um subconjunto específico dos dados incluídos na transação (ver <<sighash_types>>). A chave de assinatura é a chave privada do usuário. O resultado é a assinatura:

latexmath:[\(Sig = F_{sig}(F_{hash}(m), dA)\)]

onde:

* _dA_ é a chave privada que assina
* _m_ é a transação (ou partes dela)
* _F_~_hash_~ é a função de hash
* _F_~_sig_~ é o algoritmo de assinatura
* _Sig_ é a assinatura resultante

Mais detalhes sobre a matemática do Algoritmo de Assinatura Digital de Curva Elíptica (ECDSA) podem ser encontrados em <<ecdsa_math>>.

A função _F_~_sig_~ produz uma assinatura +Sig+ que é composta de dois valores, comumente referidos como +R+ e +S+:

----
Sig = (R, S)
----

((("Regras de Codificação Distintas (DER)")))Agora que os dois valores +R+ e +S+ foram calculados, eles são serializados em um fluxo de bytes usando um esquema de codificação padronizado internacional denominado _Regras de Codificação Distintas_ (em inglês, _Distinguished Encoding Rules_ ou _DER_).

[[seralization_of_signatures_der]]
===== Serialização de assinaturas (DER)

Vejamos novamente a transação que a Alice ((("casos de uso", "comprando café", id="alicesixtwo")))criou. Na entrada da transação, há um script de destravamento que contém a seguinte assinatura codificada em DER pela carteira da Alice:

----
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
----

Essa assinatura é um stream de bytes serializado dos valores +R+ e +S+ produzidos pela carteira da Alice para provar que ela possui a chave privada autorizada a gastar aquela saída. O formato de serialização consiste em nove elementos, abaixo descritos:

* +0x30+&#x2014;indicando o início de uma sequência DER
* +0x45+&#x2014;o comprimento da sequência (69 bytes)
  * +0x02+&#x2014;segue-se um valor inteiro
  * +0x21+&#x2014;o comprimento do número inteiro (33 bytes)
  * +R+&#x2014;++00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb++
  * +0x02+&#x2014;segue-se um outro valor inteiro
  * +0x20+&#x2014;o comprimento do número inteiro (32 bytes)
  * +S+&#x2014;++4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813++
* Um sufixo (+0x01+) indicando o tipo de hash utilizado (+SIGHASH_ALL+)

Veja se você consegue decodificar a assinatura serializada da Alice (codificada em DER) usando esta lista. Os números importantes são +R+ e +S+; o restante dos dados faz parte do esquema de codificação DER.

==== Verificando a Assinatura

((("assinaturas digitais", "verificando")))Para verificar a assinatura, deve-se ter a assinatura (+R+ e +S+), a transação serializada e a chave pública (que corresponde à chave privada usada para criar a assinatura). Essencialmente, a verificação de uma assinatura significa "Apenas o proprietário da chave privada que gerou esta chave pública poderia ter produzido esta assinatura nesta transação".

O algoritmo de verificação de assinatura pega a mensagem (um hash da transação ou partes dela), a chave pública do signatário e a assinatura (valores +R+ e +S+) e retorna TRUE se a assinatura for válida para esta mensagem e esta chave pública.

[[sighash_types]]
==== Tipos de Hash de Assinatura (SIGHASH)

((("assinaturas digitais", "tipos de hash de assinatura")))((("compromisso")))As assinaturas digitais são aplicadas às mensagens, que, no caso do bitcoin, são as próprias transações. A assinatura implica um _compromisso_ (um comprometimento) por parte do signatário com dados de transação específicos. Na forma mais simples, a assinatura se aplica a toda a transação, comprometendo-se com todas as entradas, todas as saídas e todos os outros campos da transação. No entanto, uma assinatura pode comprometer-se com apenas um subconjunto dos dados em uma transação, o que é útil para vários cenários, como veremos nesta seção.

((("sinalizadores SIGHASH")))Ao utilizar um sinalizador +SIGHASH+, as assinaturas do bitcoin têm uma maneira de indicar qual parte dos dados de uma transação está incluída no hash assinado pela chave privada. O sinalizador +SIGHASH+ é um único byte que é anexado à assinatura. Cada assinatura tem um sinalizador +SIGHASH+ e o sinalizador pode ser diferente de entrada para entrada. Uma transação com três entradas assinadas pode ter três assinaturas com diferentes sinalizadores +SIGHASH+, cada assinatura assinando (comprometendo-se com) diferentes partes da transação.

Remember, each input may contain a signature in its unlocking script. As a result, a transaction that contains several inputs may have signatures with different +SIGHASH+ flags that commit different parts of the transaction in each of the inputs. Note also that bitcoin transactions may contain inputs from different "owners," who may sign only one input in a partially constructed (and invalid) transaction, collaborating with others to gather all the necessary signatures to make a valid transaction. Many of the +SIGHASH+ flag types only make sense if you think of multiple participants collaborating outside the Bitcoin network and updating a partially signed transaction.

[role="pagebreak-before"]
Existem três sinalizadores +SIGHASH+: +ALL+, +NONE+ e +SINGLE+, conforme mostrado na <<sighash_types_and_their>>.

[[sighash_types_and_their]]
.Tipos de SIGHASH e seus significados
[options="header"]
|=======================
|Sinalizador +SIGHASH+| Valor | Descrição
| +ALL+ | 0x01 | A assinatura se aplica a todas as entradas e saídas
| +NONE+ | 0x02 | A assinatura se aplica a todas as entradas e nenhuma das saídas
| +SINGLE+ | 0x03 | A assinatura se aplica a todas as entradas, mas somente à saída com o mesmo número índice da entrada assinada
|=======================

Além disso, há um sinalizador modificador +SIGHASH_ANYONECANPAY+, que pode ser combinado com cada um dos sinalizadores anteriores. Quando +ANYONECANPAY+ é definido, apenas uma entrada é assinada, deixando o resto (e seus números de sequência) abertos para modificação. O +ANYONECANPAY+ tem o valor +0x80+ e é aplicado pelo operador bitwise OR, resultando nos sinalizadores combinados mostrados na <<sighash_types_with_modifiers>>.

[[sighash_types_with_modifiers]]
.Tipos de SIGHASH com modificadores e seus significados
[options="header"]
|=======================
|Sinalizador SIGHASH| Valor | Descrição
| ALL\|ANYONECANPAY | 0x81 | A assinatura se aplica a uma entrada e todas as saídas
| NONE\|ANYONECANPAY | 0x82 | A assinatura se aplica a uma entrada e nenhuma das saídas
| SINGLE\|ANYONECANPAY | 0x83 | A assinatura se aplica a uma entrada e à saída com o mesmo número índice
|=======================

Essas combinações de sinalizadores estão resumidas na <<sighash_combinations>>.

[[sighash_combinations]]
.Resumo das diferentes combinações de sighash
image::images/sighash_combinations.png["Summary of different SIGHASH flag combinations"]

Os sinalizadores +SIGHASH+ são aplicados durante a assinatura e a verificação de uma maneira que uma cópia da transação é feita e certos campos dentro dela são truncados (são definidos para comprimento zero e esvaziados). A transação resultante é serializada. O sinalizador +SIGHASH+ é adicionado ao final da transação serializada e o resultado é transformado em um hash. O próprio hash é a "mensagem" que é assinada. Dependendo de qual sinalizador +SIGHASH+ for usado, diferentes partes da transação são truncadas. O hash resultante depende de diferentes subconjuntos dos dados na transação. Ao incluir o +SIGHASH+ na última etapa antes de transformar em hash, a assinatura também compromete-se com o tipo do +SIGHASH+, de maneira que ele não possa ser alterado no futuro (por exemplo, por um minerador).

[NOTE]
====
Todos os tipos de +SIGHASH+ assinam o campo +nLocktime+ da transação (ver <<transaction_locktime_nlocktime>>). Além disso, o próprio tipo do +SIGHASH+ é anexado à transação antes de ela ser assinada, de modo que ele não possa ser modificado depois de a transação ser assinada.
====

No exemplo da transação da Alice (ver a lista em <<seralization_of_signatures_der>>), vimos que a última parte da assinatura codificada em DER era +01+, que é o sinalizador +SIGHASH_ALL+. Isso trava os dados da transação, portanto a assinatura da Alice está comprometendo-se com o estado de todas as entradas e saídas. Esta é a forma de assinatura mais comum.

Vejamos alguns dos outros tipos de +SIGHASH+ e como eles podem ser usados na prática:

+ALL|ANYONECANPAY+ :: ((("doações beneficentes")))((("casos de uso", "doações beneficentes")))Esta construção pode ser usada para fazer uma transação de "financiamento coletivo". Alguém tentando arrecadar fundos pode construir uma transação com uma única saída. A saída única da transação paga o valor da "meta" para a pessoa que está arrecadando os fundos. Essa transação obviamente não é válida, pois ela não tem entradas. No entanto, outras pessoas agora podem alterá-la adicionando suas próprias entradas, como uma doação. Elas assinam suas próprias entradas com +ALL|ANYONECANPAY+. A menos que entradas suficientes sejam coletadas para atingir o valor da saída, a transação é inválida. Cada doação serve como uma garantia de pagamento, que não pode ser coletada pela pessoa que está arrecadando os fundos até que todo o valor da meta tenha sido arrecadado.

+NONE+ :: This construction can be used to create a "bearer check" or "blank check" of a specific amount. It commits to the input, but allows the output locking script to be changed. Anyone can write their own Bitcoin address into the output locking script and redeem the transaction. However, the output value itself is locked by the signature.

+NONE|ANYONECANPAY+ :: Esta construção pode ser usada para construir um "coletor de pó". Os usuários que têm UTXOs minúsculas em suas carteiras não conseguem gastá-las, pois o custo em taxas é maior do que o valor dessas UTXOs pó. Com este tipo de assinatura, pode-se doar as UTXOs pó para qualquer pessoa agregá-las e gastá-las quando quiser.

((("Bitmask Sighash Modes")))Existem algumas propostas para modificar ou expandir o sistema +SIGHASH+. Uma dessas propostas é a _Bitmask Sighash Modes_ feita por Glenn Willen da Blockstream, como parte do projeto Elements. O objetivo é criar uma substituição flexível para os tipos de +SIGHASH+ que permite a criação de "bitmasks de entradas e saídas que sejam arbitrários e regraváveis pelos mineradores" e que possam expressar "esquemas de pré-compromisso contratual mais complexos, como ofertas assinadas com troco em uma troca de ativos distribuída".

[NOTE]
====
Você não verá os sinalizadores +SIGHASH+ apresentados como uma opção no aplicativo de carteira do usuário. Com poucas exceções, as carteiras geralmente constroem scripts P2PKH e assinam com sinalizadores +SIGHASH_ALL+. Para usar um sinalizador +SIGHASH+ diferente, você teria que escrever um software para construir e assinar transações. Ou seja, os sinalizadores +SIGHASH+ geralmente são usados por aplicativos de bitcoin de propósito especial que permitem novos usos.
====

[[ecdsa_math]]
==== Matemática do ECDSA

((("Algoritmo de Assinatura Digital de Curva Elíptica (ECDSA)")))Conforme mencionado anteriormente, as assinaturas são criadas por uma função matemática _F_~_sig_~ que produz uma assinatura composta de dois valores, o valor _R_ e o valor _S_. Nesta seção, veremos a função _F_~_sig_~ em maiores detalhes.

((("chaves públicas e privadas", "pares de chaves", "efêmeras")))O algoritmo de assinatura primeiro gera um par de chaves públicas privadas _efêmeras_ (temporárias). Este par de chaves temporárias é usado no cálculo dos valores _R_ e _S_, após uma transformação envolvendo a chave privada de assinatura e o hash da transação.

O par de chaves temporárias é baseado em um número aleatório _k_, que é usado como a chave privada temporária. A partir do _k_, geramos a chave pública temporária correspondente _P_ (calculada como _P = k*G_, da mesma forma que as chaves públicas do bitcoin são derivadas; ver <<pubkey>>). O valor _R_ da assinatura digital é então a coordenada x da chave pública efêmera _P_.

A partir daí, o algoritmo calcula o valor _S_ da assinatura, de modo que:

_S_ = __k__^-1^ (__Hash__(__m__) + __dA__ * __R__) _mod n_

onde:

* _k_ é a chave privada efêmera
* _R_ é a coordenada x da chave pública efêmera
* _dA_ é a chave privada que assina
* _m_ são os dados da transação
* _n_ é a ordem prima da curva elíptica

A verificação é o inverso da função de geração de assinatura, usando os valores _R_, _S_ e a chave pública para calcular um valor _P_, que é um ponto na curva elíptica (a chave pública efêmera usada na criação da assinatura):

_P_ = __S__^-1^ * __Hash__(__m__) * _G_ + __S__^-1^ * _R_ * _Qa_

onde:

* _R_ e _S_ são os valores da assinatura
* _Qa_ é a chave pública da Alice
* _m_ são os dados da transação que foram assinados
* _G_ é o ponto gerador da curva elíptica

Se a coordenada x do ponto calculado _P_ for igual a _R_, então o verificador pode concluir que a assinatura é válida.

Observe que, ao verificar a assinatura, a chave privada não é conhecida nem revelada.

[TIP]
====
ECDSA é necessariamente uma peça matemática bastante complicada; uma explicação completa vai além do escopo deste livro. Existe uma série de ótimos guias na internet que podem o conduzir no passo a passo: pesquise por "ECDSA explicado" ou acesse este link: https://bit.ly/2r0HhGB[].
====

==== A Importância da Aleatoriedade nas Assinaturas

((("assinaturas digitais", "aleatoriedade nas")))Conforme vimos em <<ecdsa_math>>, o algoritmo de geração de assinatura usa uma chave aleatória _k_, que serve como a base para a geração de um par de chaves pública/privada efêmeras. O valor de _k_ não é importante, _contanto que seja aleatório_. Se o mesmo valor _k_ for usado para produzir duas assinaturas em diferentes mensagens (transações), a _chave privada_ de assinatura poderá ser calculada por qualquer pessoa. Ou seja, a reutilização de um mesmo valor para _k_ em um algoritmo de assinatura leva à exposição da chave privada!

[WARNING]
====
((("advertências e cuidados", "assinaturas digitais")))Se o mesmo valor _k_ for usado no algoritmo de assinatura em duas transações diferentes, a chave privada poderá ser calculada e ser exposta por qualquer pessoa!
====

Esta não é apenas uma possibilidade teórica. Vimos esse problema levar à exposição de chaves privadas em algumas implementações diferentes de algoritmos de assinatura de transação no bitcoin. Algumas pessoas tiveram fundos roubados devido à reutilização inadvertida de um valor _k_. O motivo mais comum para a reutilização de um valor _k_ é um gerador de número aleatório inicializado incorretamente.

((("números aleatórios", "geração de número aleatório")))((("entropia", "geração de número aleatório")))((("inicialização determinística")))Para evitar essa vulnerabilidade, a prática recomendada pela indústria é não gerar _k_ com um gerador de número aleatório semeado com entropia, mas, em vez disso, usar um processo determinístico-aleatório semeado com os dados da próprio transação. Isso garante que cada transação produza um _k_ diferente. O algoritmo padrão da indústria para inicialização determinística de _k_ é definido em https://tools.ietf.org/html/rfc6979[RFC 6979], publicado pela _Internet Engineering Task Force_.

Se você estiver implementando um algoritmo para assinar transações no bitcoin, você _deve_ usar o RFC 6979 ou um algoritmo determinístico-aleatório semelhante para garantir a geração de um _k_ diferente para cada transação.((("", startref="Tdigsig06")))

=== Endereços, Saldos e Outras Abstrações do Bitcoin

((("transactions", "higher-level abstractions", id="Thigher06")))We began this chapter with the discovery that transactions look very different "behind the scenes" than how they are presented in wallets, blockchain explorers, and other user-facing applications. Many of the simplistic and familiar concepts from the earlier chapters, such as Bitcoin addresses and balances, seem to be absent from the transaction structure. We saw that transactions don't contain Bitcoin addresses, per se, but instead operate through scripts that lock and unlock discrete values of bitcoin. Balances are not present anywhere in this system and yet every wallet application prominently displays the balance of the user's wallet.

Agora que exploramos o que realmente está incluído em uma transação de bitcoin, podemos examinar como as abstrações de nível superior são derivadas dos componentes aparentemente primitivos da transação.

Vejamos novamente como a transação da Alice foi apresentada em um explorador de blocos popular (<<alice_transaction_to_bobs_cafe>>).

[[alice_transaction_to_bobs_cafe]]
.Transação da Alice para a Cafeteria do Bob
image::images/mbc2_0208.png["Alice Coffee Transaction"]

On the left side of the transaction, the blockchain explorer shows Alice's Bitcoin address as the "sender." In fact, this information is not in the transaction itself. When the blockchain explorer references the transaction it also references the previous transaction associated with the input and extracts the first output from that older transaction. Within that output is a locking script that locks the UTXO to Alice's public key hash (a P2PKH script). The blockchain explorer extracted the public key hash and encoded it using Base58Check encoding to produce and display the Bitcoin address that represents that public key.

Similarly, on the right side, the blockchain explorer shows the two outputs; the first to Bob's Bitcoin address and the second to Alice's Bitcoin address (as change). Once again, to create these Bitcoin addresses, the blockchain explorer extracted the locking script from each output, recognized it as a P2PKH script, and extracted the public-key-hash from within. Finally, the blockchain explorer reencoded each public key hash with Base58Check to produce and display the Bitcoin addresses.

If you were to click on Bob's Bitcoin address, the blockchain explorer would show you the view in <<the_balance_of_bobs_bitcoin_address>>.

[[the_balance_of_bobs_bitcoin_address]]
.The balance of Bob's Bitcoin address
image::images/mbc2_0608.png["The balance of Bob's Bitcoin address"]

The blockchain explorer displays the balance of Bob's Bitcoin address. But nowhere in the Bitcoin system is there a concept of a "balance." Rather, the values displayed here are constructed by the blockchain explorer as follows.

To construct the "Total Received" amount, the blockchain explorer first will decode the Base58Check encoding of the Bitcoin address to retrieve the 160-bit hash of Bob's public key that is encoded within the address. Then, the blockchain explorer will search through the database of transactions, looking for outputs with P2PKH locking scripts that contain Bob's public key hash. By summing up the value of all the outputs, the blockchain explorer can produce the total value received.

Constructing the current balance (displayed as "Final Balance") requires a bit more work. The blockchain explorer keeps a separate database of the outputs that are currently unspent, the UTXO set. To maintain this database, the blockchain explorer must monitor the Bitcoin network, add newly created UTXO, and remove spent UTXO, in real time, as they appear in unconfirmed transactions. This is a complicated process that depends on keeping track of transactions as they propagate, as well as maintaining consensus with the Bitcoin network to ensure that the correct chain is followed. Sometimes, the blockchain explorer goes out of sync and its perspective of the UTXO set is incomplete or incorrect.

A partir do conjunto UTXO, o explorador de blockchain soma o valor de todas as saídas não gastas que fazem referência ao hash da chave pública do Bob e produz o valor do "Saldo Final" que é exibido ao usuário.

Para produzir apenas essa tela, contendo esses dois "saldos", o explorador de blockchain precisa indexar e pesquisar dezenas, centenas ou mesmo centenas de milhares de transações.

Em resumo, as informações apresentadas aos usuários por meio de aplicativos de carteira, exploradores de blockchain e outras interfaces de usuário do bitcoin são frequentemente compostas de abstrações de nível superior que são derivadas ao se pesquisar muitas transações diferentes, ao se inspecionar seu conteúdo e ao  se manipular os dados contidos nelas. Ao apresentar essa visão simplista das transações de bitcoin, que se assemelham a cheques bancários de um remetente para um destinatário, esses aplicativos precisam abstrair muitos detalhes subjacentes. Eles se concentram principalmente nos tipos comuns de transações: P2PKH com assinaturas SIGHASH_ALL em todas as entradas. Portanto, embora os aplicativos de bitcoin possam apresentar mais de 80% de todas as transações em uma maneira fácil de ler, às vezes eles ficam perdidos quando se deparam com transações que fogem do normal. As transações que contêm scripts de travamento mais complexos, sinalizadores SIGHASH diferentes ou muitas entradas e saídas, acabam demonstrando a simplicidade e a fraqueza dessas abstrações.

Todos os dias, centenas de transações que não contêm saídas P2PKH são confirmadas na blockchain. Os exploradores de blockchain frequentemente apresentam mensagens de advertência em vermelho dizendo que eles não conseguem decodificar um endereço.

Como veremos no próximo capítulo, essas transações não são necessariamente estranhas. São transações que contêm scripts de travamento mais complexos do que o P2PKH comum. A seguir, aprenderemos a decodificar e compreender scripts mais complexos e as aplicações que eles suportam.((("", startref="Thigher06")))((("", startref="alicesixtwo")))